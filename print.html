<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">1.</strong> State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">1.1.</strong> WebAssembly runtime</a></li></ol></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">2.</strong> Blocks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blocks-verification.html"><strong aria-hidden="true">2.1.</strong> Blocks verification</a></li><li class="chapter-item expanded "><a href="blocks-authoring.html"><strong aria-hidden="true">2.2.</strong> Blocks authoring</a></li><li class="chapter-item expanded "><a href="blocks-finalization.html"><strong aria-hidden="true">2.3.</strong> Blocks finalization</a></li></ol></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">3.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="parachains.html"><strong aria-hidden="true">4.</strong> Parachains</a></li><li class="chapter-item expanded "><a href="network.html"><strong aria-hidden="true">5.</strong> Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network-transport.html"><strong aria-hidden="true">5.1.</strong> Transport</a></li><li class="chapter-item expanded "><a href="network-matrix.html"><strong aria-hidden="true">5.2.</strong> Validators matrix</a></li><li class="chapter-item expanded "><a href="network-protocol.html"><strong aria-hidden="true">5.3.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="network-kad.html"><strong aria-hidden="true">5.4.</strong> Kademlia</a></li></ol></li><li class="chapter-item expanded "><a href="session-keys.html"><strong aria-hidden="true">6.</strong> Session keys</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="state"><a class="header" href="#state">State</a></h1>
<h2 id="trie"><a class="header" href="#trie">Trie</a></h2>
<p>A <strong>trie</strong> is defined as:</p>
<ul>
<li>A <em>hash algorithm</em></li>
<li>A possibly empty tree of nodes.</li>
</ul>
<p>Each <strong>node</strong> is defined as:</p>
<ul>
<li>A <em>partial key</em> made of 4 bits <strong>nibbles</strong>.</li>
<li>Between zero and sixteen children nodes.</li>
<li>Optionally, a <strong>storage value</strong> and a <strong>storage value version</strong> (either both present or both absent). The storage value version is equal to either <code>0</code> or <code>1</code>.</li>
</ul>
<p>Nodes with exactly one child and no storage value are invalid.</p>
<p>Any given <em>trie</em> is either empty, or has one <em>node</em> with no parent and a set of nodes whose parent is also in the trie. Cycles are forbidden.</p>
<p>The <strong>key</strong> of a node is defined as the concatenation of the key of the parent, the index of the node within its parent's children list, and the partial key of the node.</p>
<p>The <strong>Merkle value</strong> of a trie is defined as:</p>
<ul>
<li>If the trie is not empty, it is equal to the hash of the <em>trie node value</em> of the trie node that serves as the common ancestor of all other trie nodes.</li>
<li>If the trie is empty, it is equal to the hash of a trie node value whose <em>Header</em> is equal to <code>0</code>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The Merkle value of a BLAKE2 empty trie is always equal to <code>0x03170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c111314</code>. The Merkle value of a Keccak256 empty trie is <code>0xbc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a</code>.</p>
</blockquote>
<h2 id="state-1"><a class="header" href="#state-1">State</a></h2>
<p>The <strong>state</strong> is composed of:</p>
<ul>
<li>One main <em>trie</em> whose hash algorithm is <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a>.</li>
<li>Zero or more child <em>trie</em>s whose hash algorithm is <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a>.</li>
</ul>
<p>TODO: talk about the Merkle value of child tries within the main trie</p>
<h2 id="proof"><a class="header" href="#proof">Proof</a></h2>
<p>A <strong>proof</strong> is a subset of a <em>state</em>.</p>
<p>It is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Number of proof entries</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Proof entry</td><td>(see below) repeated <em>Number of fragments</em> times</td><td>(variable)</td></tr>
</tbody></table>
<p>Where each element in <em>Proof entry</em> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Entry size</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Entry</td><td>Bytes</td><td><em>Entry size</em></td></tr>
</tbody></table>
<p>TODO which hash algorithm
The hash of each <em>Entry</em> must be one of:</p>
<ul>
<li>Equal to the <em>Merkle value</em> of the <em>main trie</em> of the state it is a subset of.</li>
<li>Equal to one of the <em>Children</em> of another entry of the proof.</li>
<li>Equal to the <em>Storage value</em> field of another entry of the proof.</li>
</ul>
<h2 id="trie-node-value-and-merkle-value"><a class="header" href="#trie-node-value-and-merkle-value">Trie node value and Merkle value</a></h2>
<h3 id="trie-node-value"><a class="header" href="#trie-node-value">Trie node value</a></h3>
<p>A <strong>trie node value</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Header</td><td>(see below)</td><td>1</td></tr>
<tr><td>Partial key extra length</td><td>(see below)</td><td>(variable)</td></tr>
<tr><td>Partial key</td><td>(see below)</td><td>(variable)</td></tr>
<tr><td>Children bitmap</td><td>(optional) Little endian unsigned integer</td><td>0 or 2</td></tr>
<tr><td>Storage value</td><td>(see below)</td><td>(variable)</td></tr>
<tr><td>Children</td><td>(see below) repeated 16 times</td><td>(variable)</td></tr>
</tbody></table>
<p>Where:</p>
<p><em>Header</em> is one byte that is used to determine the format of the rest of the trie node value.
If the 4 most significant bits of <em>Header</em> are equal to <code>0000</code>, then the value of all the bits of <em>Header</em> must be equal to <code>0</code>.</p>
<p>The <em>Partial key length in header</em> is defined as:</p>
<ul>
<li>If the two most significant bits of <em>Header</em> are equal to <code>01</code>, <code>10</code>, or <code>11</code>, it is equal to the 6 least significant bits of <em>Header</em>.</li>
<li>If the three most significant bits of <em>Header</em> are equal to <code>001</code>, it is equal to the 5 least significant bits of <em>Header</em>.</li>
<li>If the four most significant bits of <em>Header</em> are equal to <code>0001</code>, it is equal to the 4 least significant bits of <em>Header</em>.</li>
<li>If the <em>Header</em> is equal to <code>0</code>, is it equal to <code>0</code>.</li>
</ul>
<p>The <em>Partial key extra length</em> is defined as:</p>
<ul>
<li>If the <em>Partial key length in header</em> is equal to <code>63</code>, it is a serie of zero or more bytes equal to <code>255</code> followed with one byte that is not equal to <code>255</code>.</li>
<li>If the <em>Partial key length in header</em> is not equal to <code>63</code>, it is empty (the field is not present).</li>
</ul>
<p>The <em>Partial key length</em> is defined as the sum of the value of each byte of <em>Partial key extra length</em>, plus the value of <em>Partial key length in header</em>.</p>
<p>The <em>Partial key</em> is defined as:</p>
<ul>
<li>If <em>Partial key length</em> is an even number, a list of bytes whose length is <em>Partial key length</em> divided by 2.</li>
<li>If <em>Partial key length</em> is an uneven number, a list of bytes whose length is (1 plus <em>Partial key length</em>) divided by 2. The four most significant bits of the first byte must be equal to <code>0000</code>.
TODO: convert to nibbles</li>
</ul>
<p><em>Children bitmap</em> is present only if the most significant bit of <em>Header</em> is <code>1</code>, or if the four most significant bits of <em>Header</em> are <code>0001</code>. If <em>Children bitmap</em> is missing, it implicitly has a value of <code>0</code>.</p>
<p><em>Storage value</em> is present only if the second most significant bit of <em>Header</em> is <code>1</code>, if the three most significant bits of <em>Header</em> are <code>001</code>, or if the four most significant bits of <em>Header</em> are <code>0001</code>.</p>
<p>The <em>Storage value version</em> is defined as:</p>
<ul>
<li><code>0</code> if the second most significant bit of <em>Header</em> is <code>1</code>.</li>
<li><code>1</code> if the three most significant bits of <em>Header</em> are <code>001</code>, or if the four most significant bits of <em>Header</em> are <code>0001</code>.</li>
<li>Undefined otherwise.</li>
</ul>
<p>If the <em>Storage value version</em> is <code>0</code>, then the <em>Storage value</em> field is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Storage value size</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Storage value</td><td>Bytes</td><td><em>Storage value size</em></td></tr>
</tbody></table>
<p>If the <em>Storage value version</em> is <code>1</code>, then the <em>Storage value</em> field is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Storage value</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>Each of the 16 elements of <em>Children</em> corresponds to a bit in <em>Children bitmap</em>. The first child corresponds to the least significant bit, the second child corresponds to the second least significant bit, and so on. The last child corresponds to the most significant bit.</p>
<p>For each element of <em>Children</em>, if the corresponding bit in <em>Children bitmap</em> is <code>0</code>, then it is empty. Otherwise, it is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Child Merkle value size</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Child Merkle value</td><td>Bytes</td><td><em>Child Merkle value size</em></td></tr>
</tbody></table>
<p><em>Child Merkle value size</em> is always inferior or equal to 32.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-runtime"><a class="header" href="#webassembly-runtime">WebAssembly runtime</a></h1>
<h2 id="runtime-code"><a class="header" href="#runtime-code">Runtime code</a></h2>
<p>The <strong>runtime code</strong> is defined as either:</p>
<ul>
<li>The <strong>runtime WebAssembly</strong> (defined below).</li>
<li>The bytes <code>0x52BC537646DB8E05</code>, followed with the <a href="https://datatracker.ietf.org/doc/html/rfc8878">zstd</a>-encoded <strong>runtime WebAssembly</strong>. The decoded <strong>runtime WebAssembly</strong> must not be larger than 52428800 bytes (i.e. 50 MiB).</li>
</ul>
<p>The <em>runtime WebAssembly</em> always starts with the bytes <code>0x0061736D</code>, making it possible to unambiguously differentiate the two situations.</p>
<blockquote>
<p><strong>Note</strong>: Implementers should be aware of the danger of so-called &quot;zip bombs&quot; where a zstd-encoded payload decodes to a huge output. Implementers should make sure to cap the size of the output while the decoding is in progress.</p>
</blockquote>
<h2 id="runtime-webassembly"><a class="header" href="#runtime-webassembly">Runtime WebAssembly</a></h2>
<p>The <strong>runtime WebAssembly</strong> is defined as a <a href="https://webassembly.github.io/spec/">WebAssembly</a> program in binary format, with the following additional constraints:</p>
<ul>
<li>The WebAssembly binary must not use any of the WebAssembly extensions that was used after the launch of WebAssembly 1.0.</li>
<li>It must not have any <a href="https://webassembly.github.io/spec/core/bikeshed/#start-function%E2%91%A0"><em>start function</em>, as defined by the WebAssembly specification</a>.</li>
<li>It must either export exactly one memory named <code>memory</code>, or import exactly one memory named <code>memory</code> in module name <code>env</code>.</li>
<li>It must export a global named <code>__heap_base</code> of type <code>i32</code>.</li>
<li>TODO: runtime spec</li>
</ul>
<p>The <strong>runtime WebAssembly</strong> is allowed to import any function, whatever their signature. A host implementation must not consider a <strong>runtime WebAssembly</strong> as invalid only because it imports an unknown function or a known function with a signature that doesn't match the expected one. A host implementation must raise an error only if such a function is called during the execution of the WebAssembly.</p>
<h2 id="runtime-call"><a class="header" href="#runtime-call">Runtime call</a></h2>
<p>Given a <em>runtime WebAssembly</em>, a <em>number of heap pages</em>, a <a href="state.html"><em>state</em></a>, a <em>runtime entry point</em>, an <em>offchain functions enabled</em> boolean, and some input data, the host can <strong>do a runtime call</strong>.</p>
<p>TODO: offchain functions and keystore functions are different extensions I believe? it's unclear what is enabled/disabled together and what isn't</p>
<p>Doing a runtime call consists in the following step:</p>
<ul>
<li>Verify that the <em>runtime entry point</em> is a function exported by the <em>runtime WebAssembly</em>, and whose signature is <code>(func $runtime_entry_point (param $data i32) (param $len i32) (result i64))</code>.</li>
<li>Instantiate the <em>runtime WebAssembly</em>, as defined <a href="https://webassembly.github.io/spec/core/bikeshed/#instantiation%E2%91%A1">here</a>. The list of imports is described below.</li>
<li>Initialize the <em>overlay</em>, defined as the list of modifications performed to the state since the beginning of the execution.</li>
<li>Read the value of the <code>__heap_base</code> global exported by the <em>runtime WebAssembly</em>, and initialize a new <em>allocator</em>.</li>
<li>Use the allocator in order to allocate a buffer of size equal to the input data. Copy the input data to this buffer.</li>
<li>Invoke the <em>runtime entry point</em>, as defined <a href="https://webassembly.github.io/spec/core/bikeshed/#invocation%E2%91%A1">here</a>, passing as argument a pointer to the buffer containing the input data and the length of the input data.</li>
<li>Once the invocation is finished, TODO describe how to get output.</li>
</ul>
<p>TODO: talk about memory consumption and halting problem stuff</p>
<p>The following functions can be imported by the <strong>runtime WebAssembly</strong>:</p>
<h3 id="ext_allocator_malloc_version_1"><a class="header" href="#ext_allocator_malloc_version_1">ext_allocator_malloc_version_1</a></h3>
<pre><code>(func $ext_allocator_malloc_version_1
    (param $size i32) (result i32))
</code></pre>
<h3 id="ext_allocator_free_version_1"><a class="header" href="#ext_allocator_free_version_1">ext_allocator_free_version_1</a></h3>
<pre><code>(func $ext_allocator_free_version_1 (param $ptr i32))
</code></pre>
<h3 id="ext_storage_set_version_1"><a class="header" href="#ext_storage_set_version_1">ext_storage_set_version_1</a></h3>
<pre><code>(func $ext_storage_set_version_1
    (param $key i64) (param $value i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
<li><code>value</code>: A pointer-size to the memory location containing the value.</li>
</ul>
<p>The implementation must set the given <em>key</em> to the given <em>value</em> in the <em>overlay</em>.</p>
<h3 id="ext_storage_get_version_1"><a class="header" href="#ext_storage_get_version_1">ext_storage_get_version_1</a></h3>
<pre><code>(func $ext_storage_get_version_1
    (param $key i64) (result i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
<li>The result: a pointer-size.</li>
</ul>
<p>If the given <em>key</em> is present in the overlay, TODO</p>
<h3 id="ext_storage_clear_version_1"><a class="header" href="#ext_storage_clear_version_1">ext_storage_clear_version_1</a></h3>
<pre><code>(func $ext_storage_clear_version_1
    (param $key i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
</ul>
<p>The implementation must set the given <em>key</em> in the <em>overlay</em> to being non-existent.</p>
<h3 id="ext_storage_root_version_1"><a class="header" href="#ext_storage_root_version_1">ext_storage_root_version_1</a></h3>
<pre><code>(func $ext_storage_root_version_1
    (return i64))
</code></pre>
<p>With:</p>
<ul>
<li>The result: a pointer-size.</li>
</ul>
<p>The implementation must build a temporary <em>state</em> by applying the <em>overlay</em> to the state provided as input, then calculate the <em>Merkle value</em> of this temporary state.
The implementation then allocates a 32 bytes buffer using the same mechanism as <code>ext_allocator_malloc_version_1</code>, write the calculated Merkle value in it, and return a pointer-size to it.</p>
<blockquote>
<p><strong>Note</strong>: Runtimes are encouraged to not perform any further modification to the storage after having called this function. An implementation can use this hint in order to cache the result of its calculation for later.</p>
</blockquote>
<h3 id="ext_storage_root_version_2"><a class="header" href="#ext_storage_root_version_2">ext_storage_root_version_2</a></h3>
<pre><code>(func $ext_storage_root_version_2
    (param $version i32) (return i64))
</code></pre>
<p>This function is deprecated and shouldn't be used by runtimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A <strong>block</strong> consists in the following properties:</p>
<ul>
<li>A <em>header</em>.</li>
<li>A <em>hash</em>, which must be equal to the 32 bytes <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a> hash of the header.</li>
<li>An ordered list of transactions TODO or is it extrinsics called the <em>body</em> of the block.</li>
<li>A <em>state</em>, as described in <a href="state.html">the State</a> section.</li>
</ul>
<p>TODO: this section is weird</p>
<h2 id="block-header"><a class="header" href="#block-header">Block header</a></h2>
<p>A <em>block header</em> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Parent hash</td><td>Bytes</td><td> 32</td></tr>
<tr><td>Block number</td><td>Little endian unsigned integer</td><td>4</td></tr>
<tr><td>State root</td><td>Bytes</td><td>32</td></tr>
<tr><td>Extrinsics root</td><td>Bytes</td><td>32</td></tr>
<tr><td>Number of digest items</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Digest items</td><td>Digest item repeated <em>Number of digest items</em> times</td><td>(variable)</td></tr>
</tbody></table>
<h3 id="digest-item"><a class="header" href="#digest-item">Digest item</a></h3>
<p>A digest item is defined as one of:</p>
<p>TODO: finish here</p>
<h4 id="aura-consensus-authorities-change"><a class="header" href="#aura-consensus-authorities-change">Aura consensus authorities change</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x4</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Number of authorities</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Authorities</td><td>Bytes repeated <em>Number of authorities</em> times</td><td>32 times <code>Number of authorities</code></td></tr>
</tbody></table>
<h4 id="aura-consensus-authority-disabled"><a class="header" href="#aura-consensus-authority-disabled">Aura consensus authority disabled</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x4</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>Authority index</td><td>Little endian unsigned integer</td><td>4</td></tr>
</tbody></table>
<h4 id="aura-seal"><a class="header" href="#aura-seal">Aura seal</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x5</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h4 id="aura-slot-number"><a class="header" href="#aura-slot-number">Aura slot number</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x6</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>Slot number</td><td>Little endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<h4 id="babe-seal"><a class="header" href="#babe-seal">Babe seal</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x5</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>BABE</code></td><td>4</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h4 id="runtime-environment-update"><a class="header" href="#runtime-environment-update">Runtime environment update</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x8</td><td>1</td></tr>
</tbody></table>
<h4 id="other"><a class="header" href="#other">Other</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Data length</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Data</td><td>Bytes</td><td><code>Data length</code></td></tr>
</tbody></table>
<h2 id="genesis-block-header"><a class="header" href="#genesis-block-header">Genesis block header</a></h2>
<p>A <strong>genesis block header</strong> is a <strong>block header</strong> that respects the following constraints:</p>
<ul>
<li>The <em>parent hash</em> is equal to all 0s.</li>
<li>The <em>block number</em> is equal to 0.</li>
<li>The <em>extrinsics root</em> is equal to the <em>Merkle value</em> of an empty trie.</li>
<li>The list of digest items is empty.</li>
</ul>
<h2 id="better-block"><a class="header" href="#better-block">Better block</a></h2>
<p>Given two block headers A and B, we can define the <strong>better block</strong> as follows:</p>
<ul>
<li>If A's <em>parent hash</em> is equal to B, then A is a better block than B.</li>
<li>The better block is transitive: if A is a better block than a block header C, and that block header C is a better block than block header B, then A is also a better block header than block header B.</li>
<li>If the total number of Babe primary slots claims on A is superior to the total number of Babe primary slots claims on B, then A is a better block than B. TODO: define Babe primary slots claims</li>
</ul>
<p>TODO: https://paritytech.github.io/polkadot-sdk/book/protocol-chain-selection.html</p>
<h2 id="tree-of-blocks"><a class="header" href="#tree-of-blocks">Tree of blocks</a></h2>
<p>A <strong>tree of blocks</strong> is defined as a set of <em>block headers</em> where the <em>parent hash</em> of every block header in the set except for one is the hash of a block header that is also found in the set.</p>
<p>The <strong>best block</strong> of a <em>tree of blocks</em> is the block in the set for which there exists no <em>better block</em>. If multiple blocks are equal, which one is the <em>best block</em> is unspecified and implementation-defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-verification"><a class="header" href="#blocks-verification">Blocks verification</a></h1>
<p>There exists two levels of verification of a block: validating the block and executing the block.</p>
<p>A client implementation can assume that a block that successfully executes also successfully validates.
TODO: say that it's a runtime bug it it's not the case or something</p>
<h2 id="header-validation"><a class="header" href="#header-validation">Header validation</a></h2>
<p>A host can <em>validate</em> a block header.</p>
<p>A <strong>genesis block header</strong> is always valid and doesn't need to be validated.</p>
<p>Validating a non-genesis block header is done by following these steps:</p>
<ul>
<li>Validating the <em>block header</em> whose hash is equal to the <em>parent hash</em> of the block to validate.</li>
<li>Verify that the <em>block number</em> of the block header to verify is equal to the <em>block number</em> of the parent plus one.
TODO</li>
</ul>
<h2 id="block-execution"><a class="header" href="#block-execution">Block execution</a></h2>
<p>A host can <em>execute</em> a block. Executing a block also validates the header of this block.</p>
<p>A genesis block is assumed to always succeed execution.</p>
<p>Executing a block is done by following these steps:</p>
<ul>
<li>Executing the block whose hash is equal to the <em>parent hash</em> of the block to execute.</li>
<li>Obtain the <em>state root</em> of the block header whose hash is equal to the <em>parent hash</em> of the block to execute.</li>
<li>Obtain the state whose state root is equal to the <em>state root</em> obtained at the previous step.</li>
<li>Obtain the <em>runtime WebAssembly code</em> of that state.</li>
<li>TODO check entry point API version</li>
<li>Execute the entry point named <em>BlockBuilder_check_inherents</em>.</li>
<li>Execute the entry point named <em>Core_execute_block</em>. The input is equal to the concatenation of the <em>block header</em> to verify with the body of the block. If execution fails, then the block is invalid. The output must be empty.</li>
<li>Check whether the new state is valid. TODO means check if new runtime code is valid, something else?</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The block execution will fail if the body that was provided doesn't correspond to the <em>extrinsics root</em> field of the header. If the block was downloaded from an untrusted source, implementers should be aware that the body might have been modified by this untrusted source. For this reason, in that situation implementers are encouraged to check whether the body matches the <em>extrinsics root</em> prior to starting the execution.</p>
</blockquote>
<p>Because the block execution requires providing a timestamp, its execution may succeed or fail based on this timestamp. A client implementation can assume that a block execution that has succeeded with a certain timestamp will always succeed as well with any newer timestamp. In other words, once a block has executed successfully once, executing it again in the future will succeed as well.</p>
<p>TODO: should a host try executing again in case the execution succeeds in the future? the answer is no but this must be clarified</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-authoring"><a class="header" href="#blocks-authoring">Blocks authoring</a></h1>
<h2 id="better-block-1"><a class="header" href="#better-block-1">Better block</a></h2>
<p>Given two block headers A and B, we can define the <strong>better block</strong> as follows:</p>
<ul>
<li>If A's <em>parent hash</em> is equal to B, then A is a better block than B.</li>
<li>The better block is transitive: if A is a better block than a block header C, and that block header C is a better block than block header B, then A is also a better block header than block header B.</li>
<li>If the total number of Babe primary slots claims on A is superior to the total number of Babe primary slots claims on B, then A is a better block than B. TODO: define Babe primary slots claims</li>
</ul>
<p>TODO: https://paritytech.github.io/polkadot-sdk/book/protocol-chain-selection.html</p>
<p>TODO: a block is always better if it is in the finalized chain</p>
<h2 id="validators-set"><a class="header" href="#validators-set">Validators set</a></h2>
<p>The <strong>Aura validators set</strong> and the <strong>Babe validators set</strong> of a block can be determined in two different ways: through block headers and through a runtime call. Only the runtime call method is available for genesis blocks (in other words, blocks whose <em>block number</em> is equal to 0).</p>
<p>Through block headers:</p>
<ul>
<li>For the <strong>Aura validators set</strong>:
<ul>
<li>If the block doesn't have any Aura digest item, the Aura validators set is empty.</li>
<li>If the block has an Aura consensus digest item of type &quot;Authorities change&quot;, the Aura validators set is equal to that list. TODO: what if there's a OnDisabled in the same block header</li>
<li>Otherwise, the Aura validators set is identical to the Aura validators set of the block whose hash is equal to the <code>parent_hash</code> of the block.</li>
</ul>
</li>
<li>TODO babe</li>
</ul>
<p>Through a runtime call:</p>
<ul>
<li>For the <strong>Aura validators set</strong>:
<ul>
<li>AuraApi_authorities</li>
</ul>
</li>
</ul>
<p>A client implementation can assume that these two methods produce the same result. TODO: what if it doesn't</p>
<blockquote>
<p><strong>Note</strong>: The <em>Aura validators set</em> and <em>Babe validators set</em> of a block describe the list of validators that must author children of that block. The block itself must have been authored by one of the validators in the validators set of its parent block.</p>
</blockquote>
<h2 id="next-slot-claim"><a class="header" href="#next-slot-claim">Next slot claim</a></h2>
<p>Given a block and an sr25519 private key, the next <strong>claimable Babe primary slot</strong> of a block is:</p>
<ul>
<li>If the sr25519 public key correspondoing to the private key is not part of the Babe validators set of that block: never.</li>
<li>TODO</li>
</ul>
<p>Given a block and an sr25519 public key, the next <strong>claimable Babe secondary slot</strong> of a block is:</p>
<ul>
<li>If the sr25519 public key is not part of the Babe validators set of that block: never.</li>
<li>TODO</li>
</ul>
<p>Given a block and an ed25519 public key, the next <strong>claimable Aura slot</strong> of a block is:</p>
<ul>
<li>If the ed25519 public key is not part of the Aura validators set of that block: never.</li>
<li>TODO</li>
</ul>
<h2 id="authoring-a-block"><a class="header" href="#authoring-a-block">Authoring a block</a></h2>
<p>Given a <em>tree of blocks</em>, an ed25519 or an sr25519 private key, and a list of transactions TODO detail what that means, <strong>authoring a block</strong> consists in the following steps:</p>
<ul>
<li>Determine the next claimable Aura slot, next claimable Babe primary slot, and the next Babe claimable secondary slot of the <em>best block</em> of the tree and private key combination.</li>
<li>Wait until one of these three slots, whichever comes first. TODO: explain how to convert to timestamp</li>
<li>Do a runtime call for <code>Core_initialize_block</code> using the state of the <em>best block</em> (see above), passing as parameter a <em>block header</em> with the following field values:
<ul>
<li><em>Parent_hash</em> must be equal to the hash of the <em>best block</em>.</li>
<li><em>Block number</em> must be equal to the <em>block number</em> of the <em>best block</em> plus one.</li>
<li><em>State root</em> must be all zeroes.</li>
<li><em>Extrinsics root</em> must be all zeroes.</li>
<li>One digest item: if the slot is an Aura slot, TODO finish.</li>
</ul>
</li>
<li>Call <code>BlockBuilder_inherent_extrinsics</code> TODO detail the input  TODO: it's not possible to decode the output without the runtime at the moment</li>
<li>For each extrinsic returned <code>BlockBuilder_inherent_extrinsics</code>, call <code>BlockBuilder_apply_extrinsic</code>. TODO detail return value</li>
<li>For each transaction, call <code>BlockBuilder_apply_extrinsic</code>. If this runtime call fails, the block authoring process must continue and the transaction and any transaction that <em>comes after</em> must be ignored for the remainder of the block authoring operation. TODO details and indicate for how long</li>
<li>Call <code>BlockBuilder_finalize_block</code>, with an empty input.</li>
<li>Create a digital signature of the <em>block header</em> using the ed25519 or sr25519 private key.</li>
<li>Add to the digest items of the <em>block header</em> either an <em>Aura seal</em> or a <em>Babe seal</em> (depending on whether the slot was an Aura slot or a Babe slot) digest item containing the signature. Add one to the <em>number of digest items</em> of the <em>block header</em>.</li>
</ul>
<p>If at any point in the future the client authors a block again using the same private key, it <strong>must</strong> include in the set of blocks the newly-authored block.
This constraint is necessary in order to guarantee that no two blocks using the same key are authored using the same slot.</p>
<h3 id="inherents"><a class="header" href="#inherents">Inherents</a></h3>
<p>The <strong>inherents</strong> are defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>timstap0</code></td><td>8</td></tr>
<tr><td>TODO: len</td><td></td><td></td></tr>
<tr><td>Timestamp</td><td>Little-endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<p>The <code>Timestamp</code> field must contain the current Unix time, in other words the number of milliseconds since the Unix epoch ignoring leap seconds.</p>
<p>TODO parachain inherents
https://github.com/paritytech/polkadot-sdk/blob/408af9b32d95acbbac5e18bee66fd1b74230a699/polkadot/primitives/src/v6/mod.rs#L1429</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-finalization"><a class="header" href="#blocks-finalization">Blocks finalization</a></h1>
<h2 id="grandpa-validators-set"><a class="header" href="#grandpa-validators-set">Grandpa validators set</a></h2>
<p>Given a <em>block header</em>, the <strong>grandpa validators set</strong> can be determined through the following process:</p>
<p>TODO finish</p>
<ul>
<li>Find the first ancestor that has a Grandpa digest item.</li>
</ul>
<p>TODO make it clear that for forced changes the block must have been executed, otherwise security issue</p>
<blockquote>
<p><strong>Note</strong>: The <em>Grandpa validators set</em> of a block corresponds to the list of validators that can finalize blocks that are children of the block in question. The block itself must be finalized by validators of the validators set of the parent block.</p>
</blockquote>
<p>The <strong>validators set id</strong> of a block can be determined through:</p>
<p>TODO</p>
<h2 id="grandpa-commits-and-justifications"><a class="header" href="#grandpa-commits-and-justifications">Grandpa commits and justifications</a></h2>
<h3 id="grandpa-commit"><a class="header" href="#grandpa-commit">Grandpa commit</a></h3>
<p>A <strong>Grandpa commit</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Number of precommits</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Precommits</td><td>Vote (see below) repeated <em>Number of precommits</em> times</td><td>36 or 40 times <em>Number of precommits</em> TODO</td></tr>
<tr><td>Number of authentication data</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Authentication data</td><td>Authentication data (see below) repeated <em>Number of authentication data</em> times</td><td>96 times <em>Number of authentication data</em></td></tr>
</tbody></table>
<p>Where a <strong>Vote</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
</tbody></table>
<p>And <strong>Authentication data</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Signature</td><td>Bytes</td><td>64</td></tr>
<tr><td>Authority public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h3 id="grandpa-justification"><a class="header" href="#grandpa-justification">Grandpa justification</a></h3>
<p>A <strong>Grandpa justification</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Number of precommits</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Precommits</td><td>Vote (see below) repeated <em>Number of precommits</em> times</td><td>36 or 40 times <em>Number of precommits</em> TODO</td></tr>
<tr><td>Number of vote ancestries</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Vote ancestries</td><td>Block header repeated <em>Number of vote ancestries</em> times</td><td>(variable)</td></tr>
</tbody></table>
<p>Where a <strong>Vote</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>64</td></tr>
<tr><td>Authority public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>A <em>Grandpa commit</em> or <em>Grandpa justification</em> can be <strong>verified</strong> by following these steps:</p>
<ul>
<li>Fail the verification if there exists an <em>autority public key</em> that isn't present in the <em>Grandpa validators set</em> of the parent of the target block.</li>
<li>Fail the verification if there exists two <em>authority public key</em>s that are equal.</li>
<li>Fail the verification if the number of precommits is strictly inferior to <code>length(Grandpa validators set(parent)) * 2 / 3 + 1</code>. TODO: not satisfied with equation like that</li>
<li>Fail the verification if the target block hash/number of any of the votes isn't equal or a descendant of the target block hash/number of the commit/justification.</li>
<li>TODO verify signatures</li>
<li>TODO verify block ancestries</li>
</ul>
<h2 id="finalized-block"><a class="header" href="#finalized-block">Finalized block</a></h2>
<p>Given a <em>tree of blocks</em>, a set of <em>verified Grandpa commit</em>s, and a set of <em>verified Grandpa justification</em>s, the <strong>latest finalized block</strong> is defined as the block with the highest <em>block number</em> TODO explain better</p>
<p>TODO: explain that there must be no gap in the commits and justifications ^ </p>
<p>An implementation can assume that when it adds a new <em>Grandpa commit</em> or <em>Grandpa justification</em> to the set, the <em>latest finalized block</em> can only ever become a descendant of the previous <em>latest finalized block</em>. TODO unclear
If this assumption happened to be violated, the chain can be declared broken. Broken chains are out of scope of this specification. TODO: explain this somewhere this</p>
<blockquote>
<p><strong>Note</strong>: Thanks to this assumption, many of the block characteristics that an implementation typically puts in a cache (such as the Grandpa validators set) only need to be tracked for the latest finalized block and its descendants.</p>
</blockquote>
<p>A block is <strong>finalized</strong> either if it is equal to the <em>latest finalized block</em>, or if it is the parent of a <em>finalized</em> block.</p>
<blockquote>
<p><strong>Note</strong>: In other words, the <em>latest finalized block</em> and all of its ancestors (and no other block besides them) are <em>finalized</em>.</p>
</blockquote>
<h2 id="finalizable-block"><a class="header" href="#finalizable-block">Finalizable block</a></h2>
<p>A <em>block header</em> is <strong>finalizable</strong> if all of the following is true:</p>
<ul>
<li>Its parent block is <em>finalized</em> or <em>finalizable</em>.</li>
<li>If the <em>validators set id</em> of the block is different from the <em>validators set id</em> of its parent block, its parent block must be <em>finalized</em>.</li>
<li>TODO: parachain stuff https://paritytech.github.io/polkadot-sdk/book/protocol-chain-selection.html</li>
</ul>
<h2 id="grandpa-round"><a class="header" href="#grandpa-round">Grandpa round</a></h2>
<p>Given a <em>tree of blocks</em>, set of prevote <em>block headers</em> that are found in the tree, a set of precommit <em>block headers</em> that are found in the tree, and a <em>number of validators</em>:</p>
<p>TODO: explain that votes must have a valid signature</p>
<p>TODO: associate prevotes and precommits to a public key and a round number</p>
<p>The <strong>active validators set</strong> is defined as the <em>grandpa validators set</em> of the <em>latest finalized block</em> of that tree.</p>
<p>The <strong>primary validator</strong> is defined as the public key in the <em>active validators set</em> whose index is equal to <code>round number modulo length(active validators set)</code>.</p>
<p>The <strong>equivocating validators</strong> are the set of public keys associated to at least two different prevotes or at least two different precommits.</p>
<p>The <strong>supermajority threshold</strong> is defined as <code>(length(active validators set) - length(equivocating validators)) * 2 / 3 + 1</code>.</p>
<p>The <strong>prevotes ghost</strong> is defined as the highest block header in the prevotes that has a supermajority of the threshold.
If the number of prevote <em>block headers</em> is too small, the prevotes ghost is undefined.
TODO explain better</p>
<blockquote>
<p><strong>Note</strong>: As more block headers are added to the set of prevotes, the prevotes ghost can only ever move to higher blocks.</p>
</blockquote>
<p>The <strong>precommits ghost</strong> is defined as the highest block header in the precommits that has a supermajority of the threshold.
If the number of prevote <em>block headers</em> is too small, the precommits ghost is undefined.
TODO explain better</p>
<p>The <strong>estimate</strong> is defined as the precommit block header inferior or equal to the <em>prevotes ghost</em> that can potentially achieve a supermajority of the threshold.
TODO: define more formally</p>
<blockquote>
<p><strong>Note</strong>: More informally, the estimate is the highest block that could still potentially achieve a supermajority.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: As more precommit block headers are added to the set, the estimate can only ever move to lower blocks. As more prevote block headers are added to the set, the estimate can only ever move to higher blocks.</p>
</blockquote>
<p>A round is <strong>completable</strong> if either:</p>
<ul>
<li>The <em>estimate</em> is strictly inferior to the <em>prevotes ghost</em>.</li>
<li>It becomes impossible for the <em>estimate</em> to become strictly superior to the <em>prevotes ghost</em>. TODO: define more formally?</li>
</ul>
<blockquote>
<p><strong>Note</strong>: A completable round necessarily has a defined prevotes ghost.</p>
</blockquote>
<p>A <em>completable</em> round can be turned into a <em>Grandpa commit</em> or a <em>Grandpa justification</em> whose <em>target block hash</em> and <em>target block number</em> is the <em>precommits ghost</em> of the round.</p>
<blockquote>
<p><strong>Note</strong>: In other words, once a round is completable, its precommits ghost can be finalized.</p>
</blockquote>
<p>TODO: once a round is completable, <code>round - 1</code> can be completely closed and all votes discarded (source: Alistair)
TODO: this means that there are always 2 rounds running at any given time</p>
<h2 id="grandpa-voter"><a class="header" href="#grandpa-voter">Grandpa voter</a></h2>
<p>The <strong>Grandpa voter</strong> algorithm is defined as:</p>
<ul>
<li>If the public key corresponding to the Grandpa key is <em>not</em> equal to the primary, wait for either 2 seconds or the round is completable, whatever comes first.</li>
</ul>
<p>TODO: </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>A <strong>transaction</strong> is defined as an opaque list of bytes.</p>
<p>An implementation should not try to interpret the format of a transaction.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Given a <em>block</em>, a transaction can be <strong>validated</strong> against this particular block by following these steps:</p>
<ul>
<li>Check the version of the <code>TaggedTransactionQueue</code> API in the runtime specification. If the version is not equal to either <code>2</code> or <code>3</code>, the validation fails.</li>
<li>If the API version is equal to <code>2</code>, perform a <em>runtime call</em> of the function <code>Core_initialize_block</code>. TODO more precise</li>
<li>Perform a <em>runtime call</em> of the function <code>TaggedTransactionQueue_validate_transaction</code>. TODO more precise</li>
</ul>
<p>TODO</p>
<h2 id="transactions-ordering"><a class="header" href="#transactions-ordering">Transactions ordering</a></h2>
<p>TODO: explain relationship with blocks</p>
<p>Given two validated transactions A and B, the <strong>ordering</strong> of A and B is defined as:</p>
<ul>
<li>If the intersection of A's <code>provides</code> tags list with B's <code>requires</code> tags is non-empty, then B must come <strong>after</strong> A. TODO: what if A's requires overlaps with B's provides at the same time?</li>
<li>Otherwise, if A's <code>priority</code> is strictly superior to B's <code>priority</code>, then B must come <strong>after</strong> A.</li>
<li>Otherwise, A and B are <strong>equal</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parachains"><a class="header" href="#parachains">Parachains</a></h1>
<h2 id="collation"><a class="header" href="#collation">Collation</a></h2>
<p>A <strong>collation</strong> is defined as:</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<h2 id="about-conformance"><a class="header" href="#about-conformance">About conformance</a></h2>
<p>While this document should be used as a reference document when it comes to reviewing an implementation or writing tests, it is important to note that the Polkadot network is a peer-to-peer network and that there exists no mechanism in order to punish non-conforming implementations.</p>
<p>While an implementation can assume that the peers it connects to follow this specification, it should not misbehave or crash if this assumption turns out to be false.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transport-protocol"><a class="header" href="#transport-protocol">Transport protocol</a></h1>
<p>A host SHOULD listen for incoming TCP connections on one or more TCP ports reachable from the Internet.</p>
<p>TODO: Noise + Yamux</p>
<h2 id="peerid"><a class="header" href="#peerid">PeerId</a></h2>
<p>A <strong>PeerId</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x002408011220</td><td>6</td></tr>
<tr><td><a href="https://www.rfc-editor.org/rfc/rfc8032.txt">Ed25519</a> public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: A <strong>PeerId</strong> used to be defined as a multihash encoding of a protobuf struct containing another protobuf struct containing the public key. In order to prevent the same public key from being representable as multiple different <strong>PeerId</strong>s, all implementations must encode this in a single consistent way that is more easily defined as specific bytes.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: A <strong>PeerId</strong> is usually displayed to programmers and end users as the <em>base58</em> encoding of its bytes.</p>
</blockquote>
<h2 id="multistream-select"><a class="header" href="#multistream-select">multistream-select</a></h2>
<p>The <strong>multistream-select</strong> protocol is a protocol allowing to negotiate a protocol.</p>
<h2 id="noise"><a class="header" href="#noise">Noise</a></h2>
<p>The <strong>Noise</strong> protocol is the the Noise protocol defined by <a href="https://noiseprotocol.org/noise.html">https://noiseprotocol.org/noise.html</a> and using the XX handshake.
TODO libp2p handshake</p>
<h2 id="yamux"><a class="header" href="#yamux">Yamux</a></h2>
<p>TODO: https://github.com/hashicorp/yamux/blob/master/spec.md</p>
<h2 id="supported-protocols"><a class="header" href="#supported-protocols">Supported protocols</a></h2>
<h3 id="tcpip"><a class="header" href="#tcpip">TCP/IP</a></h3>
<p>In order to connect to a multiaddress of the format <code>/ip4/.../tcp/...</code>, <code>/ip4/.../tcp/.../ws</code>, <code>/ip4/.../tcp/.../tls/ws</code>, <code>/ip6/.../tcp/...</code>, <code>/ip6/.../tcp/.../ws</code>, or <code>/ip6/.../tcp/.../tls/ws</code>, an implementation must:</p>
<ul>
<li>Open a TCP/IP connection to the given IP address and port.</li>
<li>(ony for multiaddresses ending with <code>/ws</code> or <code>/tls/ws</code>) Perform <a href="https://datatracker.ietf.org/doc/html/rfc6455">a WebSocket (for <code>/ws</code>) or WebSocket secure (for <code>/tls/ws</code>)</a> handshake, where the subprotocol name is empty. All further messages must be wrapped within WebSocket binary frames.</li>
<li>Perform a multistream-select negotiation for the protocol named <code>/noise</code>.</li>
<li>Perform a Noise protocol handshake. All further messages must be encrypted and wrapped within Noise frames.</li>
<li>Perform a multistream-select negotiation for the protocol named <code>/yamux/1.0.0</code>.</li>
</ul>
<p>Multiaddresses of the format <code>/ip4/.../tcp/.../wss</code> and <code>/ip6/.../tcp/.../wss</code> must also be supported and are equivalent to respectively <code>/ip4/.../tcp/.../tls/ws</code> and <code>/ip6/.../tcp/.../tls/ws</code>. These multiaddresses are deprecated and will be removed in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators-matrix"><a class="header" href="#validators-matrix">Validators matrix</a></h1>
<h2 id="topology"><a class="header" href="#topology">Topology</a></h2>
<p>Given a <em>block</em>, the <strong>validators topology</strong> can be calculated by:</p>
<ul>
<li>Perform a runtime call to <code>Babe_currentEpoch</code>. TODO more precise</li>
<li>Calculate the <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a> hash of the concatenation of the ASCII string <code>gossipsu</code> with the Babe randomness.</li>
<li>Get the list of authorities. (how?)</li>
<li>Do this lol https://docs.rs/rand/latest/src/rand/seq/mod.rs.html#244-245</li>
<li>Calculate the square root (rounded down) of the number of authorities.</li>
<li>TODO https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/grid_topology.rs#L122</li>
</ul>
<p>TODO: https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/gossip-support/src/lib.rs#L579</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-protocols"><a class="header" href="#networking-protocols">Networking protocols</a></h1>
<p>After an encrypted multiplexed connection is open between two peers, a <strong>substream</strong> can be opened on the connection through the following steps:</p>
<ul>
<li>One side (called &quot;the initiator&quot;) opens a substream using the underlying multiplexing protocol.</li>
<li>The initiator of the substream then starts a <strong>multistream-select</strong> negotiation, as described in <a href="./network-transport.html">the transport protocol</a> section. The name of the protocol being negotiated must be one of the protocol names found later down this section.</li>
<li>Once the <strong>multistream-select</strong> negotiation is finished, the rest of the steps depend on the protocol that has been negotiated.</li>
</ul>
<p>An implementation should reject substreams (using the substream rejection mechanism of the underlying multiplexing protocol) if too many substreams are already opened.</p>
<p>In the protocol names below, the string <code>&lt;genesis-hash-and-fork-id&gt;</code> should be replaced with the <strong>lower-case-hexadecimal-encoded 32 bytes hash of the genesis block of the chain</strong>.</p>
<blockquote>
<p><strong>Example</strong>: For the Polkadot network, this string is <code>91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3</code>. The &quot;sync&quot; protocol name is thus <code>/91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3/sync/sync/2</code>.</p>
</blockquote>
<h2 id="request-response-protocols"><a class="header" href="#request-response-protocols">Request-response protocols</a></h2>
<p>This sub-section contains a list of <strong>request-response protocols</strong>.</p>
<p>A request-response protocol works as follows:</p>
<ul>
<li>After the <strong>multistream-select</strong> negotiation is finished, the initiator of the substream sends a LEB-128-encoded unsigned integer representing the size in bytes of the request.</li>
<li>The initiator of the substream then sends the request. The format of the request depends on the protocol that has been negotiated.</li>
<li>Then, either:
<ul>
<li>The other peer sends a LEB-128-encoded unsigned integer representing the size in bytes of the response, then sends the response. The format of the response depends on the protocol that has been negotiated.</li>
<li>Or the other peer closes its writing side, indicating that it refuses the answer the request.</li>
</ul>
</li>
<li>The initiator and the other peer close their writing side. TODO: explain that it can be done in parallel, or draw a diagram or something</li>
<li>The substream is closed after the two peers have closed their writing side.</li>
</ul>
<p>No reason is provided to the requester when the responder refuses to answer the request.</p>
<h3 id="sync"><a class="header" href="#sync">Sync</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/sync/sync/2</code></p>
<p>TODO https://github.com/paritytech/polkadot-sdk/blob/408af9b32d95acbbac5e18bee66fd1b74230a699/substrate/client/network/sync/src/schema/api.v1.proto#L5</p>
<p>The <strong>request</strong> is defined as the encoding of the <code>BlockRequest</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package api.v1;

enum Direction {
	Ascending = 0;
	Descending = 1;
}

message BlockRequest {
	uint32 fields = 1;
	oneof from_block {
		bytes hash = 2;
		bytes number = 3;
	}
	Direction direction = 5;
	uint32 max_blocks = 6; // optional
	bool support_multiple_justifications = 7; // optional
}
</code></pre>
<p>The <strong>response</strong> is defined as the encoding of the <code>BlockResponse</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package api.v1;

message BlockResponse {
	repeated BlockData blocks = 1;
}

message BlockData {
	// Block header hash.
	bytes hash = 1;
	// Block header if requested.
	bytes header = 2; // optional
	// Block body if requested.
	repeated bytes body = 3; // optional
	// Block receipt if requested.
	bytes receipt = 4; // optional
	// Block message queue if requested.
	bytes message_queue = 5; // optional
	// Justification if requested.
	bytes justification = 6; // optional
	// True if justification should be treated as present but empty.
	// This hack is unfortunately necessary because shortcomings in the protobuf format otherwise
	// doesn't make in possible to differentiate between a lack of justification and an empty
	// justification.
	bool is_empty_justification = 7; // optional, false if absent
	// Justifications if requested.
	// Unlike the field for a single justification, this field does not required an associated
	// boolean to differentiate between the lack of justifications and empty justification(s). This
	// is because empty justifications, like all justifications, are paired with a non-empty
	// consensus engine ID.
	bytes justifications = 8; // optional
	// Indexed block body if requestd.
	repeated bytes indexed_body = 9; // optional
}
</code></pre>
<h3 id="warp-sync"><a class="header" href="#warp-sync">Warp sync</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/sync/warp</code></p>
<p>The <strong>request</strong> is as follows:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Starting block hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is as follows:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Number of fragments</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Fragment</td><td>Fragment repeated <em>Number of fragments</em> times</td><td>(variable)</td></tr>
<tr><td>Is finished</td><td>Boolean (<code>true</code> is any non-zero value)</td><td>1</td></tr>
</tbody></table>
<p>Where a <strong>fragment</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Header</td><td>Block header</td><td>(variable)</td></tr>
<tr><td>Justification</td><td>Grandpa justification TODO link</td><td>(variable)</td></tr>
</tbody></table>
<p>TODO: what happens if block hash unknown</p>
<h3 id="state-2"><a class="header" href="#state-2">State</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/state/2</code></p>
<p>The <strong>request</strong> is defined as the encoding of the <code>StateRequest</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package api.v1;

message StateRequest {
	bytes block = 1;
	repeated bytes start = 2; // optional
	bool no_proof = 3;
}
</code></pre>
<p>The <strong>response</strong> is defined as the encoding of the <code>StateResponse</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package api.v1;

message StateResponse {
	// A collection of keys-values states. Only populated if `no_proof` is `true`
	repeated KeyValueStateEntry entries = 1;
	// If `no_proof` is false in request, this contains proof nodes.
	bytes proof = 2;
}

// A key value state.
message KeyValueStateEntry {
	// Root of for this level, empty length bytes
	// if top level.
	bytes state_root = 1;
	// A collection of keys-values.
	repeated StateEntry entries = 2;
	// Set to true when there are no more keys to return.
	bool complete = 3;
}

// A key-value pair.
message StateEntry {
	bytes key = 1;
	bytes value = 2;
}
</code></pre>
<p>TODO clean up</p>
<h3 id="light"><a class="header" href="#light">Light</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/light/2</code></p>
<p>The <strong>request</strong> is defined as the encoding of the <code>Request</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto2&quot;;

package api.v1.light;

message Request {
	oneof request {
		RemoteCallRequest remote_call_request = 1;
		RemoteReadRequest remote_read_request = 2;
		RemoteReadChildRequest remote_read_child_request = 4;
	}
}

message RemoteCallRequest {
	required bytes block = 2;
	required string method = 3;
	required bytes data = 4;
}

message RemoteReadRequest {
	required bytes block = 2;
	repeated bytes keys = 3;
}

message RemoteReadChildRequest {
	required bytes block = 2;
	required bytes storage_key = 3;
	repeated bytes keys = 6;
}
</code></pre>
<p>TODO describe fields</p>
<p>The <strong>response</strong> is defined as the encoding of the <code>Response</code> protobuf struct in the following document:</p>
<pre><code class="language-protobuf">syntax = &quot;proto2&quot;;

package api.v1.light;

message Response {
	oneof response {
		RemoteCallResponse remote_call_response = 1;
		RemoteReadResponse remote_read_response = 2;
	}
}

message RemoteCallResponse {
	optional bytes proof = 2;
}

message RemoteReadResponse {
	optional bytes proof = 2;
}
</code></pre>
<p>The <code>proof</code> is TODO
TODO: the proof can be missing if the remote refuses to answer, which is redundant with the closing of the substream, maybe clean this with an RFC</p>
<h3 id="kademlia"><a class="header" href="#kademlia">Kademlia</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/kad</code></p>
<p>The <strong>request</strong> is defined as:</p>
<p>The <strong>response</strong> is defined as:</p>
<p>Invalid multiaddresses should be ignored. Implementations should not consider the entire response as invalid just because one multiaddress is invalid.</p>
<p>The responder should make a reasonable effort to send back only multiaddresses that it thinks are reachable to itself. The responsing side should not try to determine whether a multiaddress will be reachable by the requester.</p>
<p>The requester should be aware of the fact that the list of multiaddresses can't be trusted. A multiaddress might be unreachable, point to a non-conforming implementation, or point to an implementation whose <strong>PeerId</strong> is different from the one indicated.</p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the Kademlia protocol of the libp2p library, apart from the protocol name which differs.</p>
</blockquote>
<p>TODO: for protocols below, see config at https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/request_response/mod.rs#L192</p>
<h3 id="chunk-fetching"><a class="header" href="#chunk-fetching">Chunk fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_chunk/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Validator index</td><td>Little-endian unsigned integer</td><td>4</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as one of:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Size of chunk</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Chunk</td><td>Bytes</td><td><em>Size of chunk</em></td></tr>
<tr><td>Proof</td><td>Merkle proof</td><td>(variable)</td></tr>
</tbody></table>
<p>TODO: Merkle proof is a Vec&lt;Vec<u8>&gt;, make sure to define that properly in state.md</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
</tbody></table>
<p>TODO</p>
<h3 id="collation-fetching-v1"><a class="header" href="#collation-fetching-v1">Collation fetching v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_collation/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Relay parent</td><td>Bytes</td><td>32</td></tr>
<tr><td>Para Id</td><td>Little-endian unsigned integer</td><td>4</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v1.rs#L102</p>
<p>TODO</p>
<h3 id="collation-fetching-v2"><a class="header" href="#collation-fetching-v2">Collation fetching v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_collation/2</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Relay parent</td><td>Bytes</td><td>32</td></tr>
<tr><td>Para Id</td><td>Little-endian unsigned integer</td><td>4</td></tr>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v1.rs#L102 (same as v1)</p>
<p>TODO</p>
<h3 id="pov-fetching"><a class="header" href="#pov-fetching">PoV fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_pov/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v1.rs#L122</p>
<p>TODO</p>
<h3 id="available-data-fetching"><a class="header" href="#available-data-fetching">Available data fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_available_data/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v1.rs#L145</p>
<p>TODO</p>
<h3 id="statement-fetching"><a class="header" href="#statement-fetching">Statement fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_statement/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Relay parent</td><td>Bytes</td><td>32</td></tr>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v1.rs#L183</p>
<p>TODO</p>
<h3 id="dispute-sending"><a class="header" href="#dispute-sending">Dispute sending</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/send_dispute/1</code></p>
<p>The <strong>request</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/primitives/src/disputes/message.rs#L44
TODO</p>
<p>The <strong>response</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
</tbody></table>
<h3 id="attested-candidate-request"><a class="header" href="#attested-candidate-request">Attested candidate request</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_attested_candidate/2</code></p>
<p>The <strong>request</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Candidate hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Seconded in group mask</td><td>Bits field</td><td>(variable)</td></tr>
<tr><td>Validated in group mask</td><td>Bits field</td><td>(variable)</td></tr>
</tbody></table>
<p>The <strong>response</strong> is defined as:</p>
<p>https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/request_response/v2.rs#L46</p>
<p>TODO</p>
<h2 id="notification-protocols"><a class="header" href="#notification-protocols">Notification protocols</a></h2>
<h3 id="block-announces"><a class="header" href="#block-announces">Block announces</a></h3>
<p>The format of the handshake is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Role</td><td>(see below)</td><td>1</td></tr>
<tr><td>Best block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8</td></tr>
<tr><td>Best block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Genesis block hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: The genesis block hash field is a redundant information.  TODO write an RFC about that</p>
</blockquote>
<p>Where <em>Role</em> is one of:</p>
<ul>
<li><code>0x1</code>: Full node capabilities.</li>
<li><code>0x2</code>: Light client capabilities.</li>
<li><code>0x4</code>: Authorities capabilities.</li>
</ul>
<p>TODO explain Role and consider renaming through an RFC</p>
<p>The format of a notification is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Header</td><td>Block header</td><td>(variable)</td></tr>
<tr><td>Is new best</td><td>Boolean (<code>true</code> if non-zero value)</td><td>1</td></tr>
</tbody></table>
<p>TODO: missing a field</p>
<p>An implementation should send a block announce notification only if it would be capable of later answering a <em>Sync</em> protocol request concerning this block.</p>
<p>An implementation must not send a block annouce notification concerning a block header that hasn't been <a href="./blocks-verification.html"><em>validated</em></a>.</p>
<h3 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h3>
<p>The <em>transactions</em> notifications substream should be opened only after a <em>block announces</em> notifications substream has been opened.</p>
<p>The <em>handshake</em> of this substream is an empty set of bytes.</p>
<blockquote>
<p><strong>Note</strong>: The handshake phase is identical to the one of the other notification protocols and consists in sending a <code>0</code> byte in order to indicate that the handshake payload is empty.</p>
</blockquote>
<p>The format of a notification is:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Number of transactions</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Transaction</td><td>Bytes repeated <em>Number of transactions</em> times</td><td>(variable)</td></tr>
</tbody></table>
<p>TODO: transactions aren't decodable, thus this table is meh, would be fixed by https://github.com/polkadot-fellows/RFCs/pull/56</p>
<p>Implementers are encouraged to send only one transaction per notification.
TODO: maybe update for https://github.com/polkadot-fellows/RFCs/pull/56 if it is merged before this spec is finished</p>
<p>When it receives a notification, an implementation should add the transaction to TODO.</p>
<h3 id="grandpa"><a class="header" href="#grandpa">Grandpa</a></h3>
<p>The format of the handshake is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Role</td><td>(see below)</td><td>1</td></tr>
</tbody></table>
<p>Where <em>Role</em> is one of:</p>
<ul>
<li><code>0x1</code>: Full node capabilities.</li>
<li><code>0x2</code>: Light client capabilities.</li>
<li><code>0x4</code>: Authorities capabilities.</li>
</ul>
<p>An implementation can use the <code>Role</code> of a peer as a hint in order to determine the priority level at which it broadcasts notifications to that peer.</p>
<p>The format of a notification is one of the following:</p>
<h4 id="neighbor-packet"><a class="header" href="#neighbor-packet">Neighbor packet</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Commit finalized height</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
</tbody></table>
<h4 id="commit-message"><a class="header" href="#commit-message">Commit message</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Grandpa commit</td><td>Grandpa commit TODO link</td><td>(variable)</td></tr>
</tbody></table>
<h4 id="vote"><a class="header" href="#vote">Vote</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Vote type</td><td>(see below)</td><td>1</td></tr>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>64</td></tr>
<tr><td>Authority public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>Where <em>Vote type</em> is one of:</p>
<ul>
<li><code>0x0</code>: Prevote</li>
<li><code>0x1</code>: Precommit</li>
<li><code>0x2</code>: Primary propose</li>
</ul>
<p>An implementation should send a vote grandpa notification only if it would be capable of later answering a <em>Sync</em> protocol request concerning the target block.</p>
<h4 id="catch-up-request"><a class="header" href="#catch-up-request">Catch-up request</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x3</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<h3 id="catch-up-response"><a class="header" href="#catch-up-response">Catch-up response</a></h3>
<p>TODO: according to smoldot the set id is before the round number, whereas everywhere else it's the other way around, check whether smoldot is wrong or if it's actually like that</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x4</td><td>1</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Number of prevotes</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Prevotes</td><td>(see below) repeated <em>Number of prevotes</em> times</td><td>36 or 40 times <em>Number of prevotes</em> TODO</td></tr>
<tr><td>Number of precommits</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Precommits</td><td>(see below) repeated <em>Number of precommits</em> times</td><td>36 or 40 times <em>Number of precommits</em>  TODO</td></tr>
<tr><td>Base block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Base block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
</tbody></table>
<p>Where each item in <em>Prevotes</em> and <em>Precommits</em> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>64</td></tr>
<tr><td>Authority public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h3 id="validation-v1"><a class="header" href="#validation-v1">Validation v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/validation/1</code></p>
<p>TODO</p>
<h3 id="validation-v2"><a class="header" href="#validation-v2">Validation v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/validation/2</code></p>
<p>TODO</p>
<h3 id="collation-v1"><a class="header" href="#collation-v1">Collation v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/collation/1</code></p>
<p>The format of a notification is one of the following:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Collator public key</td><td>Bytes</td><td>32</td></tr>
<tr><td>Para Id</td><td>Little-endian unsigned integer</td><td>4</td></tr>
<tr><td>Collator signature</td><td>Bytes</td><td>64</td></tr>
</tbody></table>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Collation hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>TODO: collation seconded https://github.com/paritytech/polkadot-sdk/blob/9a111fdc6ed81506033efe29920161f55a34a151/polkadot/node/network/protocol/src/lib.rs#L581</p>
<p>TODO explain protocol</p>
<h3 id="collation-v2"><a class="header" href="#collation-v2">Collation v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/collation/2</code></p>
<p>TODO: see https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/lib.rs#L463
https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/peer_set.rs#L283</p>
<h2 id="other-1"><a class="header" href="#other-1">Other</a></h2>
<h3 id="ping"><a class="header" href="#ping">Ping</a></h3>
<p><strong>Protocol name</strong>: <code>/ipfs/ping/1.0.0</code></p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the ping protocol of the libp2p library.</p>
</blockquote>
<p>TODO: finish</p>
<h3 id="identify"><a class="header" href="#identify">Identify</a></h3>
<p><strong>Protocol name</strong>: <code>/ipfs/id/1.0.0</code></p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the identify protocol of the libp2p library.</p>
</blockquote>
<p>After the protocol has been negotiated on a substream, the receiving side of the substream sends back its identification information.</p>
<p>The identification information is the encoding of the following protobuf definition:</p>
<pre><code class="language-protobuf">syntax = &quot;proto2&quot;;
message Identify {
  optional string protocolVersion = 5;
  optional string agentVersion = 6;
  optional bytes publicKey = 1;
  repeated bytes listenAddrs = 2;
  optional bytes observedAddr = 4;
  repeated string protocols = 3;
}
</code></pre>
<p>The side that opened the substream can close its writing side either before or after receiving the response, at its discretion.</p>
<p>TODO finish</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kademlia-1"><a class="header" href="#kademlia-1">Kademlia</a></h1>
<h2 id="authority-discovery"><a class="header" href="#authority-discovery">Authority discovery</a></h2>
<p>The <strong>authority-discovery validators set</strong> of a <em>block header</em> is defined as the output of the runtime call to <code>AuthorityDiscoveryApi_authorities</code>.</p>
<p>TODO: define the format</p>
<p>An <strong>authority-discovery record</strong> is defined as the encoding of the <code>SignedAuthorityRecord</code> message in the following protobuf definition file:</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package authority_discovery_v2;

message AuthorityRecord {
	repeated bytes addresses = 1;
}

message PeerSignature {
	bytes signature = 1;
	bytes public_key = 2;
}

message SignedAuthorityRecord {
	bytes record = 1;
	bytes auth_signature = 2;
	PeerSignature peer_signature = 3;
}
</code></pre>
<p>Where:</p>
<ul>
<li>The <code>record</code> field of <code>SignedAuthorityRecord</code> is the encoding of the <code>AuthorityRecord</code> protobuf message.</li>
<li>Each element of the <code>addresses</code> field must end with <code>/p2p/...</code>. TODO define better</li>
<li>The <code>public_key</code> field of the <code>peer_signature</code> is in the following format:</li>
</ul>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x08011220</td><td>4</td></tr>
<tr><td><a href="https://www.rfc-editor.org/rfc/rfc8032.txt">Ed25519</a> Public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<ul>
<li>The <em>public key</em> of the <em>PeerId</em>s at the end of <code>addresses</code>, and the <em>public key</em> of <code>peer_signature</code> must all be identical.</li>
</ul>
<p>An <em>authority-discovery record</em> is valid if:</p>
<ul>
<li>The <code>auth_signature</code> is a valid cryptographic signature of the payload <code>record</code> with the public key of the authorit-discovery authority. TODO unclear</li>
<li>The <code>signature</code> in <code>PeerSignature</code> is a valid cryptographic signature of the payload <code>record</code> with the <code>PeerId</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-keys"><a class="header" href="#session-keys">Session keys</a></h1>
<p>TODO: https://github.com/paritytech/polkadot-sdk/blob/408af9b32d95acbbac5e18bee66fd1b74230a699/substrate/primitives/core/src/crypto.rs#L1145</p>
<p>When the <code>ext_crypto_ed25519_generate_version_1</code>, <code>ext_crypto_sr25519_generate_version_1</code>, or <code>ext_crypto_ecdsa_generate_version_1</code> host functions are called by the runtime during a runtime call, the implementation must persist the private key. In other words, the private key should be stored on disk.</p>
<blockquote>
<p><strong>Note</strong>: These host functions are not always legal to call. See the appropriate section for more information.</p>
</blockquote>
<p>Additionally, an implementation must start performing some actions based on the <code>key_type</code> parameter that was provided when calling the host function. The <code>key_types</code> that require additional actions are:</p>
<ul>
<li><code>aura</code></li>
<li><code>babe</code></li>
<li><code>gran</code></li>
<li><code>audi</code></li>
<li><code>para</code></li>
</ul>
<p>TODO: parachain stuff?</p>
<p>Any other <code>key_type</code> doesn't require any further action.</p>
<h2 id="aura-and-babe"><a class="header" href="#aura-and-babe">Aura and Babe</a></h2>
<p>In order to handle a key of type <code>aura</code> or <code>babe</code>, an implementation must:</p>
<p>TODO: find a way to add links to the rest of the spec</p>
<ul>
<li>Maintain a tree of blocks that successfully pass block execution.</li>
<li>Run offchain workers. TODO clarify</li>
<li>Maintain a set of valid transactions.</li>
<li>Try as hard as possible to gather blocks from the other peers.</li>
<li>Try as hard as possible to gather transactions from the other peers.</li>
<li>Try to author blocks, providing the tree of blocks, key, and set of valid transactions. TODO match aura/babe key types with Aura and Babe algorithms</li>
<li>Whenever a block is successfully authored, send a block announce notification to other peers about this block.</li>
<li>Serve to other peers the blocks it successfully authors through the <code>sync</code> protocol.</li>
</ul>
<h2 id="grandpa-1"><a class="header" href="#grandpa-1">Grandpa</a></h2>
<p>In order to handle a key of type <code>gran</code>, an implementation must:</p>
<ul>
<li>Maintain a tree of blocks that successfully pass block execution.</li>
<li>Run offchain workers. TODO clarify</li>
<li>Maintain set of prevotes, precommits, Grandpa commits, and Grandpa justifications.</li>
<li>Try as hard as possible to gather blocks from the other peers.</li>
<li>Try as hard as possible to gather prevotes, precommits, Grandpa commits, and Grandpa justifications from the other peers.</li>
<li>Run the Grandpa voter algorithm.</li>
<li>Whenever a prevote or a precommit is emitted by the Grandpa voter algorithm, send it to other peers.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: This specification intentionally leaves some freedom in the choice of the block to vote for. Historically, implementations have been voting for the ancestor of the best block whose number is equal to the best block's number minus 3. Adding a gap between the best block and the block to finalize might avoid finalizing blocks that have accidentally modified the state in a way that ultimately leads to the chain stalling. However, this gap is not enforced in any way by the protocol and is intentionally not part of this specification. The exact algorithm that chooses which block to vote for should be the result of an informal dialogue within the Polkadot community.</p>
</blockquote>
<p>TODO finish</p>
<h2 id="authority-discovery-1"><a class="header" href="#authority-discovery-1">Authority discovery</a></h2>
<p>In order to handle a key of type <code>audi</code>, an implementation must:</p>
<ul>
<li>Maintain a tree of blocks.</li>
<li>Try as hard as possible to gather blocks from the other peers.</li>
<li>If and only if the key is present in the <em>authority-discovery validators set</em> of the best block of the tree, publish a valid <em>authority-discovery record</em>.</li>
</ul>
<p>TODO</p>
<h1 id="parachain-validation"><a class="header" href="#parachain-validation">Parachain validation</a></h1>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
