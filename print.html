<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">1.</strong> State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">1.1.</strong> WebAssembly runtime</a></li></ol></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">2.</strong> Blocks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blocks-verification.html"><strong aria-hidden="true">2.1.</strong> Blocks verification</a></li><li class="chapter-item expanded "><a href="blocks-authoring.html"><strong aria-hidden="true">2.2.</strong> Blocks authoring</a></li><li class="chapter-item expanded "><a href="blocks-finalization.html"><strong aria-hidden="true">2.3.</strong> Blocks finalization</a></li></ol></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">3.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="parachains.html"><strong aria-hidden="true">4.</strong> Parachains</a></li><li class="chapter-item expanded "><a href="network.html"><strong aria-hidden="true">5.</strong> Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network-transport.html"><strong aria-hidden="true">5.1.</strong> Transport</a></li><li class="chapter-item expanded "><a href="network-matrix.html"><strong aria-hidden="true">5.2.</strong> Validators matrix</a></li><li class="chapter-item expanded "><a href="network-protocol.html"><strong aria-hidden="true">5.3.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="network-kad.html"><strong aria-hidden="true">5.4.</strong> Kademlia</a></li></ol></li><li class="chapter-item expanded "><a href="requirements.html"><strong aria-hidden="true">6.</strong> Requirements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="state"><a class="header" href="#state">State</a></h1>
<p>The so-called <strong>state</strong> is made of one or more <strong>trie</strong>s:</p>
<ul>
<li>One <strong>main trie</strong>.</li>
<li>Zero or more <strong>child tries</strong>.</li>
</ul>
<h2 id="trie"><a class="header" href="#trie">Trie</a></h2>
<p>A <strong>trie</strong> is defined as a (potentially empty) set of <em>keys</em>.
Each key has a (potentially empty) value associated to it.</p>
<p>The <strong>Merkle value of a trie</strong> is defined as:</p>
<ul>
<li>If the trie is not empty, the <strong>Merkle value of the trie node</strong> that serves as the common ancestor of all other trie nodes. </li>
<li>If the trie is empty, it is equal to the hash of TODO</li>
</ul>
<h2 id="trie-node-value-and-merkle-value"><a class="header" href="#trie-node-value-and-merkle-value">Trie node value and Merkle value</a></h2>
<p>A <strong>trie node value</strong> is defined as the concatenation of the following bytes:</p>
<ul>
<li>TODO</li>
</ul>
<p>The <strong>Merkle value of a trie node</strong> is:</p>
<ul>
<li>If the <strong>trie node value</strong> is less than 32 bytes, the trie node value itself.</li>
<li>If the <strong>trie node value</strong> is 32 bytes or more, then the 32 bytes <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a> hash of the trie node value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-runtime"><a class="header" href="#webassembly-runtime">WebAssembly runtime</a></h1>
<h2 id="runtime-code"><a class="header" href="#runtime-code">Runtime code</a></h2>
<p>The <strong>runtime code</strong> is defined as either:</p>
<ul>
<li>The <strong>runtime WebAssembly</strong> (defined below).</li>
<li>The bytes <code>0x52BC537646DB8E05</code>, followed with the <a href="https://datatracker.ietf.org/doc/html/rfc8878">zstd</a>-encoded <strong>runtime WebAssembly</strong>. The decoded <strong>runtime WebAssembly</strong> must not be larger than 52428800 bytes (i.e. 50 MiB).</li>
</ul>
<p>The <em>runtime WebAssembly</em> always starts with the bytes <code>0x0061736D</code>, making it possible to unambiguously differentiate the two situations.</p>
<blockquote>
<p><strong>Note</strong>: Implementers should be aware of the danger of so-called &quot;zip bombs&quot; where a zstd-encoded payload decodes to a huge output. Implementers should make sure to cap the size of the output while decoding is in progress.</p>
</blockquote>
<h2 id="runtime-webassembly"><a class="header" href="#runtime-webassembly">Runtime WebAssembly</a></h2>
<p>The <strong>runtime WebAssembly</strong> is defined as a <a href="https://webassembly.github.io/spec/">WebAssembly</a> program in binary format, with the following additional constraints:</p>
<ul>
<li>The WebAssembly binary must not use any of the WebAssembly extensions that was used after the launch of WebAssembly 1.0.</li>
<li>It must not have any <a href="https://webassembly.github.io/spec/core/bikeshed/#start-function%E2%91%A0"><em>start function</em>, as defined by the WebAssembly specification</a>.</li>
<li>It must either export exactly one memory named <code>memory</code>, or import exactly one memory named <code>memory</code> in module name <code>env</code>.</li>
<li>It must export a global named <code>__heap_base</code> of type <code>i32</code>.</li>
<li>TODO: runtime spec</li>
</ul>
<p>The <strong>runtime WebAssembly</strong> is allowed to import any function, whatever their signature. A host implementation must not consider a <strong>runtime WebAssembly</strong> as invalid only because it imports an unknown function or a known function with a signature that doesn't match the expected one. A host implementation must raise an error only if such a function is called during the execution of the WebAssembly.</p>
<h2 id="runtime-call"><a class="header" href="#runtime-call">Runtime call</a></h2>
<p>Given a <em>runtime WebAssembly</em>, a <em>number of heap pages</em>, a <a href="state.html"><em>state</em></a>, a <em>runtime entry point</em>, an <em>offchain functions enabled</em> boolean, and some input data, the host can <strong>do a runtime call</strong>.</p>
<p>TODO: offchain functions and keystore functions are different extensions I believe? it's unclear what is enabled/disabled together and what isn't</p>
<p>Doing a runtime call consists in the following step:</p>
<ul>
<li>Verify that the <em>runtime entry point</em> is a function exported by the <em>runtime WebAssembly</em>, and whose signature is <code>(func $runtime_entry_point (param $data i32) (param $len i32) (result i64))</code>.</li>
<li>Instantiate the <em>runtime WebAssembly</em>, as defined <a href="https://webassembly.github.io/spec/core/bikeshed/#instantiation%E2%91%A1">here</a>. The list of imports is described below.</li>
<li>Initialize the <em>overlay</em>, defined as the list of modifications performed to the state since the beginning of the execution.</li>
<li>Read the value of the <code>__heap_base</code> global exported by the <em>runtime WebAssembly</em>, and initialize a new <em>allocator</em>.</li>
<li>Use the allocator in order to allocate a buffer of size equal to the input data. Copy the input data to this buffer.</li>
<li>Invoke the <em>runtime entry point</em>, as defined <a href="https://webassembly.github.io/spec/core/bikeshed/#invocation%E2%91%A1">here</a>, passing as argument a pointer to the buffer containing the input data and the length of the input data.</li>
<li>Once the invocation is finished, TODO describe how to get output.</li>
</ul>
<p>TODO: talk about memory consumption and halting problem stuff</p>
<p>The following functions can be imported by the <strong>runtime WebAssembly</strong>:</p>
<h3 id="ext_allocator_malloc_version_1"><a class="header" href="#ext_allocator_malloc_version_1">ext_allocator_malloc_version_1</a></h3>
<pre><code>(func $ext_allocator_malloc_version_1
    (param $size i32) (result i32))
</code></pre>
<h3 id="ext_allocator_free_version_1"><a class="header" href="#ext_allocator_free_version_1">ext_allocator_free_version_1</a></h3>
<pre><code>(func $ext_allocator_free_version_1 (param $ptr i32))
</code></pre>
<h3 id="ext_storage_set_version_1"><a class="header" href="#ext_storage_set_version_1">ext_storage_set_version_1</a></h3>
<pre><code>(func $ext_storage_set_version_1
    (param $key i64) (param $value i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
<li><code>value</code>: A pointer-size to the memory location containing the value.</li>
</ul>
<p>The implementation must set the given <em>key</em> to the given <em>value</em> in the <em>overlay</em>.</p>
<h3 id="ext_storage_get_version_1"><a class="header" href="#ext_storage_get_version_1">ext_storage_get_version_1</a></h3>
<pre><code>(func $ext_storage_get_version_1
    (param $key i64) (result i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
<li>The result: a pointer-size.</li>
</ul>
<p>If the given <em>key</em> is present in the overlay, TODO</p>
<h3 id="ext_storage_clear_version_1"><a class="header" href="#ext_storage_clear_version_1">ext_storage_clear_version_1</a></h3>
<pre><code>(func $ext_storage_clear_version_1
    (param $key i64))
</code></pre>
<p>With:</p>
<ul>
<li><code>key</code>: A pointer-size to the memory location containing the key.</li>
</ul>
<p>The implementation must set the given <em>key</em> in the <em>overlay</em> to being non-existent.</p>
<h3 id="ext_storage_root_version_1"><a class="header" href="#ext_storage_root_version_1">ext_storage_root_version_1</a></h3>
<pre><code>(func $ext_storage_root_version_1
    (return i64))
</code></pre>
<p>With:</p>
<ul>
<li>The result: a pointer-size.</li>
</ul>
<p>The implementation must build a temporary <em>state</em> by applying the <em>overlay</em> to the state provided as input, then calculate the <em>Merkle value</em> of this temporary state.
The implementation then allocates a 32 bytes buffer using the same mechanism as <code>ext_allocator_malloc_version_1</code>, write the calculated Merkle value in it, and return a pointer-size to it.</p>
<blockquote>
<p><strong>Note</strong>: Runtimes are encouraged to not perform any further modification to the storage after having called this function. An implementation can use this hint in order to cache the result of its calculation for later.</p>
</blockquote>
<h3 id="ext_storage_root_version_2"><a class="header" href="#ext_storage_root_version_2">ext_storage_root_version_2</a></h3>
<pre><code>(func $ext_storage_root_version_2
    (param $version i32) (return i64))
</code></pre>
<p>This function is deprecated and shouldn't be used by runtimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A <strong>block</strong> consists in the following properties:</p>
<ul>
<li>A <em>header</em>.</li>
<li>A <em>hash</em>, which must be equal to the 32 bytes <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a> hash of the header.</li>
<li>An ordered list of transactions TODO or is it extrinsics called the <em>body</em> of the block.</li>
<li>A <em>state</em>, as described in <a href="state.html">the State</a> section.</li>
</ul>
<p>TODO: this section is weird</p>
<h2 id="block-header"><a class="header" href="#block-header">Block header</a></h2>
<p>A <em>block header</em> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Parent hash</td><td>Bytes</td><td> 32</td></tr>
<tr><td>Block number</td><td>Little endian unsigned integer</td><td>4</td></tr>
<tr><td>State root</td><td>Bytes</td><td>32</td></tr>
<tr><td>Extrinsics root</td><td>Bytes</td><td>32</td></tr>
<tr><td>Number of digest items</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Digest items (zero or more)</td><td>Digest item</td><td>(variable)</td></tr>
</tbody></table>
<h3 id="digest-item"><a class="header" href="#digest-item">Digest item</a></h3>
<p>A digest item is defined as one of:</p>
<p>TODO: finish here</p>
<h4 id="aura-consensus-authorities-change"><a class="header" href="#aura-consensus-authorities-change">Aura consensus authorities change</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x4</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Number of authorities</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Authorities (zero or more)</td><td>Bytes</td><td>(32 times <code>Number of authorities</code>)</td></tr>
</tbody></table>
<h4 id="aura-consensus-authority-disabled"><a class="header" href="#aura-consensus-authority-disabled">Aura consensus authority disabled</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x4</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>Authority index</td><td>Little endian unsigned integer</td><td>4</td></tr>
</tbody></table>
<h4 id="aura-seal"><a class="header" href="#aura-seal">Aura seal</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x5</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h4 id="aura-slot-number"><a class="header" href="#aura-slot-number">Aura slot number</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x6</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>aura</code></td><td>4</td></tr>
<tr><td>Slot number</td><td>Little endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<h4 id="babe-seal"><a class="header" href="#babe-seal">Babe seal</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x5</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>BABE</code></td><td>4</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<h4 id="runtime-environment-update"><a class="header" href="#runtime-environment-update">Runtime environment update</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x8</td><td>1</td></tr>
</tbody></table>
<h4 id="other"><a class="header" href="#other">Other</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Data length</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>Data</td><td>Bytes</td><td>(indicated by <code>Data length</code>)</td></tr>
</tbody></table>
<h2 id="genesis-block-header"><a class="header" href="#genesis-block-header">Genesis block header</a></h2>
<p>A <strong>genesis block header</strong> is a <strong>block header</strong> that respects the following constraints:</p>
<ul>
<li>The <em>parent hash</em> is equal to all 0s.</li>
<li>The <em>block number</em> is equal to 0.</li>
<li>The <em>extrinsics root</em> is equal to the <em>Merkle value</em> of an empty trie.</li>
<li>The list of digest items is empty.</li>
</ul>
<h2 id="better-block"><a class="header" href="#better-block">Better block</a></h2>
<p>Given two block headers A and B, we can define the <strong>better block</strong> as follows:</p>
<ul>
<li>If A's <em>parent hash</em> is equal to B, then A is a better block than B.</li>
<li>The better block is transitive: if A is a better block than a block header C, and that block header C is a better block than block header B, then A is also a better block header than block header B.</li>
<li>If the total number of Babe primary slots claims on A is superior to the total number of Babe primary slots claims on B, then A is a better block than B. TODO: define Babe primary slots claims</li>
</ul>
<p>TODO: https://paritytech.github.io/polkadot-sdk/book/protocol-chain-selection.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-verification"><a class="header" href="#blocks-verification">Blocks verification</a></h1>
<p>There exists two levels of verification of a block: validating the block and executing the block.</p>
<p>A client implementation can assume that a block that successfully executes also successfully validates.
TODO: say that it's a runtime bug it it's not the case or something</p>
<h2 id="header-validation"><a class="header" href="#header-validation">Header validation</a></h2>
<p>A host can <em>validate</em> a block header.</p>
<p>A <strong>genesis block header</strong> is always valid and doesn't need to be validated.</p>
<p>Validating a non-genesis block header is done by following these steps:</p>
<ul>
<li>Validating the <em>block header</em> whose hash is equal to the <em>parent hash</em> of the block to validate.</li>
<li>Verify that the <em>block number</em> of the block header to verify is equal to the <em>block number</em> of the parent plus one.
TODO</li>
</ul>
<h2 id="block-execution"><a class="header" href="#block-execution">Block execution</a></h2>
<p>A host can <em>execute</em> a block. Executing a block also validates the header of this block.</p>
<p>A genesis block is assumed to always succeed execution.</p>
<p>Executing a block is done by following these steps:</p>
<ul>
<li>Executing the block whose hash is equal to the <em>parent hash</em> of the block to execute.</li>
<li>Obtain the <em>state root</em> of the block header whose hash is equal to the <em>parent hash</em> of the block to execute.</li>
<li>Obtain the state whose state root is equal to the <em>state root</em> obtained at the previous step.</li>
<li>Obtain the <em>runtime WebAssembly code</em> of that state.</li>
<li>TODO check entry point API version</li>
<li>Execute the entry point named <em>BlockBuilder_check_inherents</em>.</li>
<li>Execute the entry point named <em>Core_execute_block</em>. The input is equal to the concatenation of the <em>block header</em> to verify with the body of the block. If execution fails, then the block is invalid. The output must be empty.</li>
<li>Check whether the new state is valid. TODO means check if new runtime code is valid, something else?</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The block execution will fail if the body that was provided doesn't correspond to the <em>extrinsics root</em> field of the header. If the block was downloaded from an untrusted source, implementers should be aware that the body might have been modified by this untrusted source. For this reason, in that situation implementers are encouraged to check whether the body matches the <em>extrinsics root</em> prior to starting the execution.</p>
</blockquote>
<p>Because the block execution requires providing a timestamp, its execution may succeed or fail based on this timestamp. A client implementation can assume that a block execution that has succeeded with a certain timestamp will always succeed as well with any newer timestamp. In other words, once a block has executed successfully once, executing it again in the future will succeed as well.</p>
<p>TODO: should a host try executing again in case the execution succeeds in the future? the answer is no but this must be clarified</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-authoring"><a class="header" href="#blocks-authoring">Blocks authoring</a></h1>
<h2 id="better-block-1"><a class="header" href="#better-block-1">Better block</a></h2>
<p>Given two block headers A and B, we can define the <strong>better block</strong> as follows:</p>
<ul>
<li>If A's <em>parent hash</em> is equal to B, then A is a better block than B.</li>
<li>The better block is transitive: if A is a better block than a block header C, and that block header C is a better block than block header B, then A is also a better block header than block header B.</li>
<li>If the total number of Babe primary slots claims on A is superior to the total number of Babe primary slots claims on B, then A is a better block than B. TODO: define Babe primary slots claims</li>
</ul>
<p>TODO: https://paritytech.github.io/polkadot-sdk/book/protocol-chain-selection.html</p>
<p>TODO: a block is always better if it is in the finalized chain</p>
<h2 id="validators-set"><a class="header" href="#validators-set">Validators set</a></h2>
<p>The <strong>Aura validators set</strong> and the <strong>Babe validators set</strong> of a block can be determined in two different ways: through block headers and through a runtime call. Only the runtime call method is available for genesis blocks (in other words, blocks whose <em>block number</em> is equal to 0).</p>
<p>Through block headers:</p>
<ul>
<li>For the <strong>Aura validators set</strong>:
<ul>
<li>If the block doesn't have any Aura digest item, the Aura validators set is empty.</li>
<li>If the block has an Aura consensus digest item of type &quot;Authorities change&quot;, the Aura validators set is equal to that list. TODO: what if there's a OnDisabled in the same block header</li>
<li>Otherwise, the Aura validators set is identical to the Aura validators set of the block whose hash is equal to the <code>parent_hash</code> of the block.</li>
</ul>
</li>
<li>TODO babe</li>
</ul>
<p>Through a runtime call:</p>
<ul>
<li>For the <strong>Aura validators set</strong>:
<ul>
<li>AuraApi_authorities</li>
</ul>
</li>
</ul>
<p>A client implementation can assume that these two methods produce the same result. TODO: what if it doesn't</p>
<h2 id="next-slot-claim"><a class="header" href="#next-slot-claim">Next slot claim</a></h2>
<p>Given a block and an sr25519 private key, the next <strong>claimable Babe primary slot</strong> of a block is:</p>
<ul>
<li>If the sr25519 public key correspondoing to the private key is not part of the Babe validators set of that block: never.</li>
<li>TODO</li>
</ul>
<p>Given a block and an sr25519 public key, the next <strong>claimable Babe secondary slot</strong> of a block is:</p>
<ul>
<li>If the sr25519 public key is not part of the Babe validators set of that block: never.</li>
<li>TODO</li>
</ul>
<p>Given a block and an ed25519 public key, the next <strong>claimable Aura slot</strong> of a block is:</p>
<ul>
<li>If the ed25519 public key is not part of the Aura validators set of that block: never.</li>
<li>TODO</li>
</ul>
<h2 id="authoring-a-block"><a class="header" href="#authoring-a-block">Authoring a block</a></h2>
<p>Given a set of blocks, an ed25519 or an sr25519 private key, and a list of transactions TODO detail what that means, <strong>authoring a block</strong> consists in the following steps:</p>
<ul>
<li>Find the <em>best block</em> amongst that set using the <strong>better block</strong> algorithm described above.</li>
<li>Determine the next claimable Aura slot, next claimable Babe primary slot, and the next Babe claimable secondary slot of that block and private key combination.</li>
<li>Wait until one of these three slots, whichever comes first. TODO: explain how to convert to timestamp</li>
<li>Do a runtime call for <code>Core_initialize_block</code> using the state of the <em>best block</em> (see above), passing as parameter a <em>block header</em> with the following field values:
<ul>
<li><em>Parent_hash</em> must be equal to the hash of the <em>best block</em>.</li>
<li><em>Block number</em> must be equal to the <em>block number</em> of the <em>best block</em> plus one.</li>
<li><em>State root</em> must be all zeroes.</li>
<li><em>Extrinsics root</em> must be all zeroes.</li>
<li>One digest item: if the slot is an Aura slot, TODO finish.</li>
</ul>
</li>
<li>Call <code>BlockBuilder_inherent_extrinsics</code> TODO detail the input  TODO: it's not possible to decode the output without the runtime at the moment</li>
<li>For each extrinsic returned <code>BlockBuilder_inherent_extrinsics</code>, call <code>BlockBuilder_apply_extrinsic</code>. TODO detail return value</li>
<li>For each transaction, call <code>BlockBuilder_apply_extrinsic</code>. If this runtime call fails, the block authoring process must continue and the transaction and any transaction that <em>comes after</em> must be ignored for the remainder of the block authoring operation. TODO details and indicate for how long</li>
<li>Call <code>BlockBuilder_finalize_block</code>, with an empty input.</li>
<li>Create a digital signature of the <em>block header</em> using the ed25519 or sr25519 private key.</li>
<li>Add to the digest items of the <em>block header</em> either an <em>Aura seal</em> or a <em>Babe seal</em> (depending on whether the slot was an Aura slot or a Babe slot) digest item containing the signature. Add one to the <em>number of digest items</em> of the <em>block header</em>.</li>
</ul>
<p>If at any point in the future the client authors a block again using the same private key, it <strong>must</strong> include in the set of blocks the newly-authored block.
This constraint is necessary in order to guarantee that no two blocks using the same key are authored using the same slot.</p>
<h3 id="inherents"><a class="header" href="#inherents">Inherents</a></h3>
<p>The <strong>inherents</strong> are defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>(constant)</td><td>ASCII string <code>timstap0</code></td><td>8</td></tr>
<tr><td>TODO: len</td><td></td><td></td></tr>
<tr><td>Timestamp</td><td>Little-endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<p>The <code>Timestamp</code> field must contain the current Unix time, in other words the number of milliseconds since the Unix epoch ignoring leap seconds.</p>
<p>TODO parachain inherents
https://github.com/paritytech/polkadot-sdk/blob/408af9b32d95acbbac5e18bee66fd1b74230a699/polkadot/primitives/src/v6/mod.rs#L1429</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-finalization"><a class="header" href="#blocks-finalization">Blocks finalization</a></h1>
<h2 id="grandpa-validators-set"><a class="header" href="#grandpa-validators-set">Grandpa validators set</a></h2>
<p>Given a <em>block header</em>, the <strong>Grandpa validators set</strong> can be determined through the following process:</p>
<p>TODO</p>
<p>TODO: don't forget to remove from the list disabled validators</p>
<h2 id="finalizable-block"><a class="header" href="#finalizable-block">Finalizable block</a></h2>
<p>A <em>block header</em> is <strong>finalizable</strong> if:</p>
<ul>
<li>Its parent block is <em>finalized</em> or <em>finalizable</em>.</li>
<li>TODO: parachain stuff</li>
</ul>
<h2 id="grandpa-rounds"><a class="header" href="#grandpa-rounds">Grandpa rounds</a></h2>
<p>Given a set of prevote <em>block headers</em>, a set of precommit <em>block headers</em>, and a <em>number of validators</em>:</p>
<h3 id="threshold"><a class="header" href="#threshold">Threshold</a></h3>
<p>The <strong>threshold</strong> is defined as <code>number of validators * 2 / 3 + 1</code>.</p>
<h3 id="prevotes-ghost"><a class="header" href="#prevotes-ghost">Prevotes ghost</a></h3>
<p>The <strong>prevotes ghost</strong> is defined as the highest block header in the prevotes that has a supermajority of the threshold.
If the number of prevote <em>block headers</em> is too small, the prevotes ghost is undefined.
TODO explain better</p>
<blockquote>
<p><strong>Note</strong>: As more block headers are added, the prevotes ghost can only ever move to higher blocks.</p>
</blockquote>
<h3 id="estimate"><a class="header" href="#estimate">Estimate</a></h3>
<p>The <strong>estimate</strong> is defined as the block inferior or equal to the <em>prevotes ghost</em> that can potentially achieve a supermajority of the threshold.
TODO: define more formally</p>
<blockquote>
<p><strong>Note</strong>: More informally, the estimate is the highest block that could still potentially achieve a supermajority.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: As more precommit block headers are added to the set, the estimate can only ever move to lower blocks. As more prevote block headers are added to the set, the estimate can only ever move to higher blocks.</p>
</blockquote>
<h3 id="completable"><a class="header" href="#completable">Completable</a></h3>
<p>A round is <strong>completable</strong> if either:</p>
<ul>
<li>The <em>estimate</em> is strictly inferior to the <em>prevotes ghost</em>.</li>
<li>It becomes impossible for the <em>estimate</em> to become strictly superior to the <em>prevotes ghost</em>.</li>
</ul>
<h3 id="finality-update"><a class="header" href="#finality-update">Finality update</a></h3>
<p>The <strong>updated finalized block</strong> is defined as:</p>
<ul>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>A <strong>transaction</strong> is defined as an opaque list of bytes.</p>
<p>An implementation should not try to interpret the format of a transaction.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Given a <em>block</em>, a transaction can be <strong>validated</strong> against this particular block by following these steps:</p>
<ul>
<li>Check the version of the <code>TaggedTransactionQueue</code> API in the runtime specification. If the version is not equal to either <code>2</code> or <code>3</code>, the validation fails.</li>
<li>If the API version is equal to <code>2</code>, perform a <em>runtime call</em> of the function <code>Core_initialize_block</code>. TODO more precise</li>
<li>Perform a <em>runtime call</em> of the function <code>TaggedTransactionQueue_validate_transaction</code>. TODO more precise</li>
</ul>
<p>TODO</p>
<h2 id="transactions-ordering"><a class="header" href="#transactions-ordering">Transactions ordering</a></h2>
<p>TODO: explain relationship with blocks</p>
<p>Given two validated transactions A and B, the <strong>ordering</strong> of A and B is defined as:</p>
<ul>
<li>If the intersection of A's <code>provides</code> tags list with B's <code>requires</code> tags is non-empty, then B must come <strong>after</strong> A. TODO: what if A's requires overlaps with B's provides at the same time?</li>
<li>Otherwise, if A's <code>priority</code> is strictly superior to B's <code>priority</code>, then B must come <strong>after</strong> A.</li>
<li>Otherwise, A and B are <strong>equal</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parachains"><a class="header" href="#parachains">Parachains</a></h1>
<h2 id="collation"><a class="header" href="#collation">Collation</a></h2>
<p>A <strong>collation</strong> is defined as:</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<h2 id="about-conformance"><a class="header" href="#about-conformance">About conformance</a></h2>
<p>While this document should be used as a reference document when it comes to reviewing an implementation or writing tests, it is important to note that the Polkadot network is a peer-to-peer network and that there exists no mechanism in order to punish non-conforming implementations.</p>
<p>While an implementation can assume that the peers it connects to follow this specification, it should not misbehave or crash if this assumption turns out to be false.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transport-protocol"><a class="header" href="#transport-protocol">Transport protocol</a></h1>
<p>A host SHOULD listen for incoming TCP connections on one or more TCP ports reachable from the Internet.</p>
<p>TODO: Noise + Yamux</p>
<h2 id="peerid"><a class="header" href="#peerid">PeerId</a></h2>
<p>A <strong>PeerId</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>Bytes 0x002408011220</td><td>6</td></tr>
<tr><td><a href="https://www.rfc-editor.org/rfc/rfc8032.txt">Ed25519</a> public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: A <strong>PeerId</strong> used to be defined as a multihash encoding of a protobuf struct containing another protobuf struct containing the public key. In order to prevent the same public key from being representable as multiple different <strong>PeerId</strong>s, all implementations must encode this in a single consistent way that is more easily defined as specific bytes.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: A <strong>PeerId</strong> is usually displayed to programmers and end users as the <em>base58</em> encoding of its bytes.</p>
</blockquote>
<h2 id="multistream-select"><a class="header" href="#multistream-select">multistream-select</a></h2>
<p>The <strong>multistream-select</strong> protocol is a protocol allowing to negotiate a protocol.</p>
<h2 id="noise"><a class="header" href="#noise">Noise</a></h2>
<p>The <strong>Noise</strong> protocol is the the Noise protocol defined by <a href="https://noiseprotocol.org/noise.html">https://noiseprotocol.org/noise.html</a> and using the XX handshake.
TODO libp2p handshake</p>
<h2 id="yamux"><a class="header" href="#yamux">Yamux</a></h2>
<p>TODO: https://github.com/hashicorp/yamux/blob/master/spec.md</p>
<h2 id="supported-protocols"><a class="header" href="#supported-protocols">Supported protocols</a></h2>
<ul>
<li>TCP/IP</li>
<li>TCP/IP and WebSocket (secure or not)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators-matrix"><a class="header" href="#validators-matrix">Validators matrix</a></h1>
<h2 id="topology"><a class="header" href="#topology">Topology</a></h2>
<p>Given a <em>block</em>, the <strong>validators topology</strong> can be calculated by:</p>
<ul>
<li>Perform a runtime call to <code>Babe_currentEpoch</code>. TODO more precise</li>
<li>Calculate the <a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2</a> hash of the concatenation of the ASCII string <code>gossipsu</code> with the Babe randomness.</li>
<li>Get the list of authorities. (how?)</li>
<li>Do this lol https://docs.rs/rand/latest/src/rand/seq/mod.rs.html#244-245</li>
<li>Calculate the square root (rounded down) of the number of authorities.</li>
<li>TODO https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/grid_topology.rs#L122</li>
</ul>
<p>TODO: https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/gossip-support/src/lib.rs#L579</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-protocols"><a class="header" href="#networking-protocols">Networking protocols</a></h1>
<p>After an encrypted multiplexed connection is open between two peers, a <strong>substream</strong> can be opened on the connection through the following steps:</p>
<ul>
<li>One side (called &quot;the initiator&quot;) opens a substream using the underlying multiplexing protocol.</li>
<li>The initiator of the substream then starts a <strong>multistream-select</strong> negotiation, as described in <a href="./network-transport.html">the transport protocol</a> section. The name of the protocol being negotiated must be one of the protocol names found later down this section.</li>
<li>Once the <strong>multistream-select</strong> negotiation is finished, the rest of the steps depend on the protocol that has been negotiated.</li>
</ul>
<p>An implementation should reject substreams (using the substream rejection mechanism of the underlying multiplexing protocol) if too many substreams are already opened.</p>
<p>In the protocol names below, the string <code>&lt;genesis-hash-and-fork-id&gt;</code> should be replaced with the <strong>lower-case-hexadecimal-encoded 32 bytes hash of the genesis block of the chain</strong>.</p>
<blockquote>
<p><strong>Example</strong>: For the Polkadot network, this string is <code>91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3</code>. The &quot;sync&quot; protocol name is thus <code>/91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3/sync/sync/2</code>.</p>
</blockquote>
<h2 id="request-response-protocols"><a class="header" href="#request-response-protocols">Request-response protocols</a></h2>
<p>This sub-section contains a list of <strong>request-response protocols</strong>.</p>
<p>A request-response protocol works as follows:</p>
<ul>
<li>After the <strong>multistream-select</strong> negotiation is finished, the initiator of the substream sends a LEB-128-encoded unsigned integer representing the size in bytes of the request.</li>
<li>The initiator of the substream then sends the request. The format of the request depends on the protocol that has been negotiated.</li>
<li>Then, either:
<ul>
<li>The other peer sends a LEB-128-encoded unsigned integer representing the size in bytes of the response, then sends the response. The format of the response depends on the protocol that has been negotiated.</li>
<li>Or the other peer closes its writing side, indicating that it refuses the answer the request.</li>
</ul>
</li>
<li>The initiator and the other peer close their writing side. TODO: explain that it can be done in parallel, or draw a diagram or something</li>
<li>The substream is closed after the two peers have closed their writing side.</li>
</ul>
<p>No reason is provided to the requester when the responder refuses to answer the request.</p>
<h3 id="sync"><a class="header" href="#sync">Sync</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/sync/sync/2</code></p>
<h3 id="warp-sync"><a class="header" href="#warp-sync">Warp sync</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/sync/warp</code></p>
<p>The <strong>request</strong> is as follows:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Starting block hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>The <strong>response</strong> is as follows:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Number of fragments</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Fragment</td><td>Fragment</td><td>(variable)</td></tr>
<tr><td>Is finished</td><td>Boolean (<code>true</code> is any non-zero value)</td><td>1</td></tr>
</tbody></table>
<p>Where a <strong>fragment</strong> is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Header</td><td>Block header</td><td>(variable)</td></tr>
<tr><td>Justification</td><td>Justification</td><td>(variable)</td></tr>
</tbody></table>
<p>TODO: what happens if block hash unknown</p>
<h3 id="state-1"><a class="header" href="#state-1">State</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/state/2</code></p>
<h3 id="light"><a class="header" href="#light">Light</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/light/2</code></p>
<h3 id="kademlia"><a class="header" href="#kademlia">Kademlia</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/kad</code></p>
<p>Invalid multiaddresses should be ignored. Implementations should not consider the entire response as invalid just because one multiaddress is invalid.</p>
<p>An implementation of the responsing side should make a reasonable effort to send back only multiaddresses that it thinks are reachable to it.</p>
<p>The requesting side should be aware of the fact that the list of multiaddresses can't be untrusted. A multiaddress might be unreachable, point to a non-conforming implementation, or point to an implementation whose <strong>PeerId</strong> is different from the one indicated.</p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the Kademlia protocol of the libp2p library, apart from the protocol name which differs.</p>
</blockquote>
<p>TODO: for protocols below, see config at https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/request_response/mod.rs#L192</p>
<h3 id="chunk-fetching"><a class="header" href="#chunk-fetching">Chunk fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_chunk/1</code></p>
<h3 id="collation-fetching-v1"><a class="header" href="#collation-fetching-v1">Collation fetching v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_collation/1</code></p>
<h3 id="collation-fetching-v2"><a class="header" href="#collation-fetching-v2">Collation fetching v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_collation/2</code></p>
<h3 id="pov-fetching"><a class="header" href="#pov-fetching">PoV fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_pov/1</code></p>
<h3 id="available-data-fetching"><a class="header" href="#available-data-fetching">Available data fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_available_data/1</code></p>
<h3 id="statement-fetching"><a class="header" href="#statement-fetching">Statement fetching</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_statement/1</code></p>
<h3 id="dispute-sending"><a class="header" href="#dispute-sending">Dispute sending</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/send_dispute/1</code></p>
<h3 id="attested-candidate-request"><a class="header" href="#attested-candidate-request">Attested candidate request</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/req_attested_candidate/2</code></p>
<h2 id="notification-protocols"><a class="header" href="#notification-protocols">Notification protocols</a></h2>
<h3 id="block-announces"><a class="header" href="#block-announces">Block announces</a></h3>
<p>The format of the handshake is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Role</td><td>Role</td><td>1</td></tr>
<tr><td>Best block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8</td></tr>
<tr><td>Best block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Genesis block hash</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: The genesis block hash field is a redundant information.  TODO write an RFC about that</p>
</blockquote>
<p>Where <code>Role</code> is one of:</p>
<ul>
<li><code>0x1</code>: Full node capabilities.</li>
<li><code>0x2</code>: Light client capabilities.</li>
<li><code>0x4</code>: Authorities capabilities.</li>
</ul>
<p>TODO explain Role and consider renaming through an RFC</p>
<p>The format of a notification is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Header</td><td>Block header</td><td>(variable)</td></tr>
<tr><td>Is new best</td><td>Boolean (<code>true</code> if non-zero value)</td><td>1</td></tr>
</tbody></table>
<p>TODO: missing a field</p>
<p>An implementation should send a block announce notification only if it would be capable of later answering a <em>Sync</em> protocol request concerning this block.</p>
<p>An implementation must not send a block annouce notification concerning a block header that hasn't been <a href="./blocks-verification.html"><em>validated</em></a>.</p>
<h3 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h3>
<p>The <em>transactions</em> notifications substream should be opened only after a <em>block announces</em> notifications substream has been opened.</p>
<p>The <em>handshake</em> of this substream is an empty set of bytes.</p>
<blockquote>
<p><strong>Note</strong>: The handshake phase is identical to the one of the other notification protocols and consists in sending a <code>0</code> byte in order to indicate that the handshake payload is empty.</p>
</blockquote>
<p>The format of a notification is:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Number of transactions</td><td>SCALE-compact-encoded unsigned integer</td><td>(variable)</td></tr>
<tr><td>(repeated) Transaction</td><td>Bytes</td><td>(variable)</td></tr>
</tbody></table>
<p>TODO: transactions aren't decodable, thus this table is meh, would be fixed by https://github.com/polkadot-fellows/RFCs/pull/56</p>
<p>Implementers are encouraged to send only one transaction per notification.
TODO: maybe update for https://github.com/polkadot-fellows/RFCs/pull/56 if it is merged before this spec is finished</p>
<p>When it receives a notification, an implementation should add the transaction to TODO.</p>
<h3 id="grandpa"><a class="header" href="#grandpa">Grandpa</a></h3>
<p>The format of the handshake is defined as:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>Role</td><td>Role</td><td>1</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: <code>Role</code> is defined in the <em>Block announces</em> section.</p>
</blockquote>
<p>The format of a notification is one of the following:</p>
<h4 id="neighbor-packet"><a class="header" href="#neighbor-packet">Neighbor packet</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x2</td><td>1</td></tr>
<tr><td>(constant)</td><td>0x1</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Commit finalized height</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
</tbody></table>
<p>TODO commit message</p>
<h4 id="vote"><a class="header" href="#vote">Vote</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x0</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Vote type</td><td>Vote type</td><td>1</td></tr>
<tr><td>Target block hash</td><td>Bytes</td><td>32</td></tr>
<tr><td>Target block number</td><td>Little endian unsigned integer</td><td>4 TODO or 8 due to block number</td></tr>
<tr><td>Signature</td><td>Bytes</td><td>64</td></tr>
<tr><td>Authority public key</td><td>Bytes</td><td>32</td></tr>
</tbody></table>
<p>Where <code>Vote type</code> is one of:</p>
<ul>
<li><code>0x0</code>: Prevote</li>
<li><code>0x1</code>: Precommit</li>
<li><code>0x2</code>: Primary propose</li>
</ul>
<p>An implementation should send a vote grandpa notification only if it would be capable of later answering a <em>Sync</em> protocol request concerning the target block.</p>
<h4 id="catch-up-request"><a class="header" href="#catch-up-request">Catch-up request</a></h4>
<table><thead><tr><th>Field name</th><th>Type</th><th>Size (bytes)</th></tr></thead><tbody>
<tr><td>(constant)</td><td>0x3</td><td>1</td></tr>
<tr><td>Round number</td><td>Little endian unsigned integer</td><td>8</td></tr>
<tr><td>Set ID</td><td>Little endian unsigned integer</td><td>8</td></tr>
</tbody></table>
<p>TODO: catch-up response</p>
<h3 id="validation-v1"><a class="header" href="#validation-v1">Validation v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/validation/1</code></p>
<h3 id="validation-v2"><a class="header" href="#validation-v2">Validation v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/validation/2</code></p>
<h3 id="collation-v1"><a class="header" href="#collation-v1">Collation v1</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/collation/1</code></p>
<h3 id="collation-v2"><a class="header" href="#collation-v2">Collation v2</a></h3>
<p><strong>Protocol name</strong>: <code>/&lt;genesis-hash-and-fork-id&gt;/collation/2</code></p>
<p>TODO: see https://github.com/paritytech/polkadot-sdk/tree/master/polkadot/node/network/protocol/src
https://github.com/paritytech/polkadot-sdk/blob/master/polkadot/node/network/protocol/src/peer_set.rs#L283</p>
<h2 id="other-1"><a class="header" href="#other-1">Other</a></h2>
<h3 id="ping"><a class="header" href="#ping">Ping</a></h3>
<p><strong>Protocol name</strong>: <code>/ipfs/ping/1.0.0</code></p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the ping protocol of the libp2p library.</p>
</blockquote>
<p>TODO: finish</p>
<h3 id="identify"><a class="header" href="#identify">Identify</a></h3>
<p><strong>Protocol name</strong>: <code>/ipfs/id/1.0.0</code></p>
<blockquote>
<p><strong>Note</strong>: This protocol is identical to the identify protocol of the libp2p library.</p>
</blockquote>
<p>After the protocol has been negotiated on a substream, the receiving side of the substream sends back its identification information.</p>
<p>The identification information is the encoding of the following protobuf definition:</p>
<pre><code class="language-protobuf">syntax = &quot;proto2&quot;;
message Identify {
  optional string protocolVersion = 5;
  optional string agentVersion = 6;
  optional bytes publicKey = 1;
  repeated bytes listenAddrs = 2;
  optional bytes observedAddr = 4;
  repeated string protocols = 3;
}
</code></pre>
<p>The side that opened the substream can close its writing side either before or after receiving the response, at its discretion.</p>
<p>TODO finish</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kademlia-1"><a class="header" href="#kademlia-1">Kademlia</a></h1>
<h2 id="authority-discovery"><a class="header" href="#authority-discovery">Authority discovery</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<p>In order to conform to this specification, a <strong>validator</strong> should:</p>
<ul>
<li>Listen for incoming networking connections.</li>
<li>Attempt to connect to the other nodes.</li>
<li>Publish its address using authority-discovery.</li>
<li>Author blocks at a speed superior or equal to the reference implementation running on the reference hardware. TODO define?</li>
<li>After it has authored a block, send to a large set of peers a <em>block announce</em> concerning this block.</li>
<li>Have a transactions pool.</li>
<li>Run offchain workers</li>
<li></li>
</ul>
<p>TODO finish</p>
<p>These requirements should be seen as <em>minimal requirements</em>, and are in no way a guarantee that running this validator will get rewards. It is fundamentally impossible to guarantee rewards, given that some aspects are out of control of the implementation and of the node operator (for example Internet cables being severed).</p>
<h2 id="generating-session-keys"><a class="header" href="#generating-session-keys">Generating session keys</a></h2>
<p>TODO: move this section somewhere else</p>
<p>Given a <em>block header</em>, the <strong>session keys</strong> can be generated by following these steps:</p>
<p>TODO: describe input and check API version and all</p>
<ul>
<li>Perform a <em>runtime call</em> of the function <code>SessionKeys_generate_session_keys</code>, with keystore host functions enabled.</li>
<li>The output of this runtime call is the <strong>session keys</strong>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The runtime call to <code>SessionKeys_generate_session_keys</code> is expected to call host functions such as <code>ext_crypto_sr25519_generate_version_1</code> which insert private keys into the <em>keystore</em> TODO: keystore not defined.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
